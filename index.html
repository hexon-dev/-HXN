<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Hexon — Grid</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;800&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    :root{
      --bg-top:#071027; --bg-btm:#000; --panel-bg:rgba(8,18,36,0.95);
      --muted:#bfeafc; --accent-from:#3b82f6; --accent-to:#22d3ee;
      --card-bg:rgba(255,255,255,0.03);
      --safe-pad: env(safe-area-inset-top,12px);
    }
    html,body{ height:100%; margin:0; font-family:'Orbitron',sans-serif; background:radial-gradient(circle at top,var(--bg-top),var(--bg-btm)); color:#E6F7FF; -webkit-font-smoothing:antialiased; box-sizing:border-box; overflow:auto; -webkit-overflow-scrolling:touch; }
    *,*:before,*:after{ box-sizing: inherit; }
    a { color:inherit; text-decoration:none; -webkit-tap-highlight-color: transparent; }
    #pageWrap {
      min-height: 100vh;
      padding: calc(var(--safe-pad) + 12px);
      padding-bottom: calc(env(safe-area-inset-bottom,12px) + 80px);
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      align-items: start;
      justify-items: stretch;
      width: 100%;
      overflow-x: hidden;
      overflow-y: auto;
    }
    @media (min-width: 900px) {
      #pageWrap { grid-template-columns: minmax(320px, 1fr) 340px; gap: 18px; padding: 18px; padding-bottom: calc(env(safe-area-inset-bottom,12px) + 18px); }
    }
    #pageWrap > * { min-width: 0; }
    #phaserCanvas {
      width: 100%;
      max-width: 100%;
      border-radius: 12px;
      overflow: hidden;
      background: linear-gradient(180deg,#061426,#041016);
      display: flex;
      align-items: center;
      justify-content: center;
      box-sizing:border-box;
      min-height: 260px;
      max-height: 80vh;
      margin: 0 auto;
      position: relative;
      z-index: 0;
      min-width: 0;
    }
    #phaserCanvas canvas { width: 100% !important; height: auto !important; display:block; max-width:100%; }
    #uiPanel{ width:100%; max-width: 100%; background: linear-gradient(180deg,var(--panel-bg), rgba(3,6,12,0.88)); padding:12px; border-radius:12px; box-shadow: 0 8px 30px rgba(0,0,0,0.6); max-height: calc(100vh - 160px); overflow:auto; -webkit-overflow-scrolling: touch; box-sizing:border-box; position: relative; z-index: 1; min-width: 0; }
    .card{ background:var(--card-bg); padding:12px; border-radius:12px; margin-bottom:12px; box-shadow:0 6px 18px rgba(0,0,0,0.45); }
    .muted{ color:var(--muted); opacity:.85; font-size:12px; }
    .stat{ font-size:20px; font-weight:700; color:#7EE7FF; }
    .small{ font-size:13px; }
    .small-muted{ font-size:12px; color:#9fcbdc; opacity:.95; }
    .energyBar{ width:100%; height:12px; background:#0f2433; border-radius:8px; overflow:hidden; margin-top:8px; }
    .energyFill{ height:100%; width:60%; background:linear-gradient(90deg,var(--accent-to),var(--accent-from)); transition:width .25s ease; }
    .button{ display:inline-block; padding:8px 12px; border-radius:8px; background:linear-gradient(90deg,var(--accent-from),var(--accent-to)); color:#021125; font-weight:700; cursor:pointer; border:0; user-select:none; }
    .btn-ghost{ background:transparent; border:1px solid rgba(126,231,255,0.12); color:#7EE7FF; padding:8px 12px; border-radius:8px; cursor:pointer; }
    input[type="text"]{ background:transparent; border:1px solid rgba(255,255,255,0.06); padding:8px; border-radius:8px; width:100%; color:inherit; box-sizing:border-box; }
    .touch-controls{ display:flex; justify-content:space-around; gap:8px; margin-top:12px; }
    .touch-btn{ padding:10px; border-radius:8px; background:rgba(255,255,255,0.04); cursor:pointer; user-select:none; display:flex; align-items:center; justify-content:center; min-width:44px; min-height:44px; }
    .touch-footer { display:none; position: fixed; left: 50%; transform: translateX(-50%); bottom: calc(env(safe-area-inset-bottom,12px) + 8px); z-index:120000; gap: 8px; padding: 8px; border-radius: 12px; background: rgba(2,6,12,0.6); backdrop-filter: blur(6px); box-shadow: 0 10px 30px rgba(0,0,0,0.6); align-items:center; }
    .touch-footer .touch-btn { margin: 0 6px; }
    @media (max-width: 900px){ .touch-footer { display:flex; } }
    .overlay{ position:fixed; inset:0; display:none; align-items:flex-end; justify-content:center; z-index:99999; background:rgba(0,0,0,0.45); padding:env(safe-area-inset-top,12px) 12px calc(env(safe-area-inset-bottom,12px) + 6px); box-sizing:border-box; }
    .overlay.show{ display:flex; }
    .bottom-sheet{ width:100%; max-width:720px; border-radius:14px; background:linear-gradient(180deg,#071423,#03101a); box-shadow:0 20px 60px rgba(0,0,0,0.6); overflow:hidden; max-height: min(86vh, calc(100vh - 96px)); display:flex; flex-direction:column; }
    .sheet-header{ padding:14px 16px; border-bottom:1px solid rgba(255,255,255,0.02); display:flex; align-items:center; justify-content:space-between; gap:8px; }
    .sheet-title{ font-weight:700; font-size:16px; color:#E6F7FF; }
    .sheet-body{ padding:12px 16px; overflow:auto; -webkit-overflow-scrolling:touch; max-height:60vh; }
    .sheet-actions{ padding:12px 16px; border-top:1px solid rgba(255,255,255,0.02); display:flex; gap:8px; justify-content:flex-end; background:linear-gradient(180deg, rgba(0,0,0,0.02), transparent); }
    .wallet-option{ padding:12px; border-radius:10px; background:transparent; display:flex; justify-content:space-between; align-items:center; border:1px solid rgba(255,255,255,0.03); margin-bottom:8px; cursor:pointer; }
    .wallet-option:active{ transform:translateY(1px); }
    .toast { position: fixed; left: 50%; transform: translateX(-50%); bottom: 16px; background: rgba(3,10,18,0.85); color: #E6F7FF; padding: 8px 12px; border-radius: 8px; box-shadow: 0 8px 24px rgba(0,0,0,0.4); font-size: 13px; z-index: 100000; display: none; }
    nav{ margin-bottom:8px; display:flex; gap:8px; overflow:auto; -webkit-overflow-scrolling:touch; flex-wrap:wrap; }
    nav a{ color:inherit; text-decoration:none; padding:6px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.03); font-weight:600; white-space:nowrap; }
    body, #pageWrap { overscroll-behavior-x: none; }
    .card input, .card .small { word-break: break-word; white-space: normal; }
    @media (max-width:360px){ .stat{ font-size:18px; } .small{ font-size:12px; } .button{ padding:7px 10px; } }
  </style>
</head>
<body class="tgmini-reset">
  <div id="pageWrap" role="application" aria-label="Hexon game">
    <div id="phaserCanvas" role="region" aria-label="Game canvas"></div>

    <aside id="uiPanel" aria-live="polite" role="complementary" aria-label="Game controls and stats">
      <nav>
        <a href="index.html"><i class="fa-solid fa-gamepad"></i> Game</a>
        <a href="shop.html"><i class="fa-solid fa-mining"></i> Miners</a>
        <a href="leaderboard.html"><i class="fa-solid fa-ranking-star"></i> Leaderboard</a>
        <a href="referrals.html"><i class="fa-solid fa-user-plus"></i> Referrals</a>
      </nav>

      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:8px;">
          <div>
            <div class="muted small">Player</div>
            <div class="stat small" id="ui-username">Guest</div>
            <div style="height:6px"></div>
            <div class="muted small">Wallet</div>
            <div class="small" id="ui-wallet">Not connected</div>
          </div>
          <div style="display:flex; flex-direction:column; gap:8px; align-items:flex-end;">
            <button id="bindWalletBtn" class="button" type="button" aria-label="Bind wallet">Bind Wallet</button>
            <button id="resetGameBtn" class="btn-ghost" type="button" aria-label="Reset game">Reset Game</button>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="small muted">Level</div>
        <div class="stat" id="ui-level">1</div>
        <div style="display:flex; gap:12px; margin-top:8px; align-items:center;">
          <div><div class="muted small">Lines</div><div class="small" id="ui-lines">0</div></div>
          <div style="margin-left:auto; text-align:right;"><div class="muted small">Score</div><div class="stat" id="ui-score">0</div></div>
        </div>
      </div>

      <div class="card">
        <div class="small muted">GP</div>
        <div class="stat" id="ui-gp">0 GP</div>
        <div class="small-muted" id="ui-gp-server" style="margin-top:6px;">server: — GP</div>
      </div>

      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div><div class="muted small">Energy</div><div class="energyBar"><div id="ui-energyFill" class="energyFill"></div></div></div>
          <div style="text-align:right; width:140px;"><div class="muted small">Auto Refill</div><div class="small" id="ui-auto">+10% / 30m</div></div>
        </div>

        <div style="display:flex; justify-content:space-between; margin-top:8px;">
          <div><div class="muted small">Sittings Left</div><div class="small" id="ui-sittings">3/3</div></div>
          <div><div class="muted small">Ads Today</div><div class="small" id="ui-adsToday">0</div></div>
        </div>

        <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">
          <button id="watchAdBtn" class="button"><i class="fa-solid fa-tv"></i> Watch Transmission</button>
          <button id="showRefBtn" class="btn-ghost"><i class="fa-solid fa-share-nodes"></i> Share Referral</button>
        </div>
      </div>

      <div class="card">
        <div class="small muted">Miners (Off-chain)</div>
        <div id="minersList" class="small" aria-live="polite" style="margin-top:8px;">
          <div class="muted small">Loading…</div>
        </div>
        <div style="margin-top:8px;">
          <button id="openStore" class="button"><i class="fa-solid fa-store"></i> Open Miner Shop</button>
        </div>
      </div>

      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div>
            <div class="muted small">Claimable HXN</div>
            <div class="stat" id="ui-hxn">— HXN</div>
            <div class="small-muted" id="ui-hxn-sub" style="margin-top:6px;">loading…</div>
          </div>
          <div style="text-align:right;">
            <div class="muted small">Hash Units</div>
            <div class="small" id="ui-au">AU: 0</div>
            <div class="small-muted" id="ui-total-au" style="margin-top:6px;">total AU: —</div>
          </div>
        </div>
        <div style="display:flex; gap:8px; margin-top:10px;">
          <button id="syncHxnBtn" class="btn-ghost"><i class="fa-solid fa-sync"></i> Sync Mining</button>
          <button id="claimRewardBtn" class="button"><i class="fa-solid fa-gift"></i> View / Claim</button>
        </div>
      </div>

      <div class="card">
        <div class="small muted">Top Scorers</div>
        <div class="leaderboard" id="leaderboard" aria-live="polite" style="margin-top:8px;">
          <div class="muted small">Loading…</div>
        </div>
      </div>

      <div class="card">
        <div class="small muted">Daily Missions</div>
        <div class="small" id="missions" style="margin-top:8px;">- Clear 50 lines<br>- Play 3 games today<br>- Invite friend (referral)</div>
      </div>

      <div class="footer muted small">Pre-launch • Season active • <span id="daysLeft">74</span> days left</div>
    </aside>
  </div>

  <div id="overlay" class="overlay" aria-hidden="true" role="dialog" aria-modal="true">
    <div class="bottom-sheet" role="document" aria-label="Inline sheet">
      <div class="sheet-header">
        <div class="sheet-title">Connect Wallet</div>
        <div><button id="sheetClose" class="btn-ghost" aria-label="Close sheet"><i class="fa-solid fa-xmark"></i></button></div>
      </div>
      <div class="sheet-body" id="sheetBody" tabindex="0">
        <div class="small-muted" style="margin-bottom:10px">Choose a wallet or paste your public key. In Telegram we open deep-links using WebApp API when available.</div>

        <div class="wallet-option" id="opt-phantom" tabindex="0" role="button" aria-pressed="false">
          <div>Phantom</div><div class="small-muted" id="det-phantom"></div>
        </div>

        <div class="wallet-option" id="opt-solflare" tabindex="0" role="button" aria-pressed="false">
          <div>Solflare</div><div class="small-muted" id="det-solflare"></div>
        </div>

        <div class="wallet-option" id="opt-backpack" tabindex="0" role="button" aria-pressed="false">
          <div>Backpack</div><div class="small-muted" id="det-backpack"></div>
        </div>

        <div class="wallet-option" id="opt-wc" tabindex="0" role="button" aria-pressed="false">
          <div><i class="fa-solid fa-link"></i> WalletConnect</div><div class="small-muted">Use a compatible mobile wallet</div>
        </div>

        <div style="height:12px"></div>

        <div class="small-muted">Manual public key</div>
        <div style="display:flex; gap:8px; margin-top:8px;">
          <input id="manualPublicKey" type="text" inputmode="text" placeholder="Paste public key here" aria-label="Public key" />
          <button id="manualBindBtn" class="button" type="button">Bind</button>
        </div>
      </div>

      <div class="sheet-actions" id="sheetActions">
        <button id="sheetCancel" class="btn-ghost" type="button">Cancel</button>
      </div>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>

  <script>
  // -----------------------
  // Config / constants
  // -----------------------
  const TELEGRAM_BOT_USERNAME = 'hxxxnbot';
  const API_BASE = 'https://extensions-charity-club-specifies.trycloudflare.com';
  const DAILY_EMISSION_CAP = 1250000; // daily HXN emission (used for preview)
  const GRID_COLS = 14, GRID_ROWS = 24;
  const BASE_CELL = 20, BASE_GAP = 2;
  const INITIAL_DROP_MS = 800;
  const ADSGRAM_SRC = 'https://sad.adsgram.ai/js/sad.min.js';
  const ADSGRAM_BLOCK_ID = 'int-22823';
  const AUTO_RECHARGE_MINUTES = 30;
  const AUTO_RECHARGE_PERCENT = 10;

  // ad config
  const MAX_ADS_PER_DAY = 9;
  const MAX_ADS_PER_SITTING = 3;
  const MAX_SITTINGS_PER_DAY = 3;
  const SITTING_COOLDOWN_MINUTES = 120; // 2 hours
  const SITTING_COOLDOWN_MS = SITTING_COOLDOWN_MINUTES * 60e3;

  const TAP_MAX_TIME = 250;
  const TAP_MAX_MOV = 14;
  const SWIPE_MIN_DIST = 30;
  const BOARD_PADDING = 16; // padding around grid inside canvas

  // -----------------------
  // Persistence keys
  // -----------------------
  const STORAGE_KEYS = {
    CLIENT: 'hexon_client',
    GAME: 'hexon_game',
    SESSION: 'hexon_session',
    BOUND_WALLET: 'hexon_bound_wallet',
    BOUND_PROVIDER: 'hexon_bound_provider',
    PENDING_REF: 'hexon_pending_ref',
    PENDING_DEEPLINK: 'hexon_pending_deeplink'
  };

  // -----------------------
  // State
  // -----------------------
  let clientState = {
    sessionId: loadSessionFromStorage() || generateUUID(),
    userId: null,
    username: null,
    telegramId: null,
    wallet: loadBoundWalletFromStorage(),
    walletProvider: localStorage.getItem(STORAGE_KEYS.BOUND_PROVIDER) || null,
    gpBase: 0,
    serverScore: null,
    energy: 100,
    energyLastUpdatedAt: Date.now(),
    miners: [],
    shopItems: [],
    userAU: 0,
    totalAU: 0,
    referralCode: null,
    pendingReferral: null,
    referralsActive: 0,
    adsThisSitting: 0,
    adsThisSittingStartedAt: null,
    sittingsUsedToday: 0,
    adsToday: 0,
    adsTodayDate: null,
    actionLog: [],
    lastSent: { gpTotal: 0, score: 0 },
    // HXN fields (server authoritative)
    hxnBalance: null,   // string numeric or null
    hxnCredits: null    // total credits from ledger (string) if returned
  };

  const gameState = {
    grid: null,
    activePiece: null,
    nextPiece: null,
    score: 0,
    level: 1,
    lines: 0,
    dropInterval: INITIAL_DROP_MS,
    isPlaying: false,
    combo: 0,
    lastSavedAt: null,
    lastTickAt: null,
    hiddenAt: null,
    wasPlayingBeforeHidden: null,
    pausedForEnergy: false,
    tickRemaining: null,
    _forceResume: false
  };

  saveSessionToStorage(clientState.sessionId);

  // -----------------------
  // Storage helpers
  // -----------------------
  function loadSessionFromStorage(){ try{return localStorage.getItem(STORAGE_KEYS.SESSION)||null;}catch(e){return null;} }
  function saveSessionToStorage(sid){ try{ if (sid) localStorage.setItem(STORAGE_KEYS.SESSION, sid); }catch(e){} }
  function loadBoundWalletFromStorage(){ try{return localStorage.getItem(STORAGE_KEYS.BOUND_WALLET)||null;}catch(e){return null;} }
  function saveBoundWalletToStorage(pk, provider){ try{ if (pk) localStorage.setItem(STORAGE_KEYS.BOUND_WALLET, pk); if (provider) localStorage.setItem(STORAGE_KEYS.BOUND_PROVIDER, provider); }catch(e){} }
  function clearBoundWalletFromStorage(){ try{ localStorage.removeItem(STORAGE_KEYS.BOUND_WALLET); localStorage.removeItem(STORAGE_KEYS.BOUND_PROVIDER); }catch(e){} }

  function saveClientToStorage(){
    try {
      const toSave = Object.assign({}, clientState);
      toSave.actionLog = (clientState.actionLog || []).slice(-2000);
      // don't store heavy or transient fields, but fine to store hxnBalance as string
      localStorage.setItem(STORAGE_KEYS.CLIENT, JSON.stringify(toSave));
    } catch(e){ console.warn('saveClientToStorage error', e); }
  }

  function saveGameToStorage(){
    try {
      const toSave = {
        grid: gameState.grid,
        activePiece: gameState.activePiece,
        nextPiece: gameState.nextPiece,
        score: gameState.score,
        level: gameState.level,
        lines: gameState.lines,
        dropInterval: gameState.dropInterval,
        isPlaying: gameState.isPlaying,
        combo: gameState.combo,
        lastSavedAt: Date.now(),
        lastTickAt: gameState.lastTickAt,
        hiddenAt: gameState.hiddenAt,
        wasPlayingBeforeHidden: gameState.wasPlayingBeforeHidden,
        pausedForEnergy: gameState.pausedForEnergy,
        tickRemaining: gameState.tickRemaining
      };
      localStorage.setItem(STORAGE_KEYS.GAME, JSON.stringify(toSave));
    } catch(e){ console.warn('saveGameToStorage error', e); }
  }

  function loadClientFromStorage(){
    try {
      const raw = localStorage.getItem(STORAGE_KEYS.CLIENT);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch(e){ return null; }
  }

  function loadGameFromStorage(){
    try {
      const raw = localStorage.getItem(STORAGE_KEYS.GAME);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch(e){ return null; }
  }

  function clearSavedGame(){ try { localStorage.removeItem(STORAGE_KEYS.GAME); } catch(e) {} }

  // -----------------------
  // Utilities
  // -----------------------
  function generateUUID(){ try{ if (window.crypto && crypto.randomUUID) return crypto.randomUUID(); }catch(e){} return 'sess-'+Math.floor(Math.random()*1e12).toString(36); }
  function $(id){ return document.getElementById(id); }
  function logAction(a,p={}){ clientState.actionLog.push({t:Date.now(), a, p}); if (clientState.actionLog.length>5000) clientState.actionLog.shift(); saveClientToStorage(); }
  function escapeHtml(str){ return String(str).replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s])); }

  // time helpers
  function isoDateStr(d = new Date()){ return d.toISOString().slice(0,10); }
  function msUntilNextLocalMidnight(){
    const n = new Date();
    const next = new Date(n.getFullYear(), n.getMonth(), n.getDate()+1);
    return next.getTime() - Date.now();
  }
  function formatMs(ms){
    if (!Number.isFinite(ms) || ms <= 0) return 'now';
    const s = Math.ceil(ms/1000);
    if (s < 60) return `${s}s`;
    const m = Math.floor(s/60);
    if (m < 60) return `${m}m`;
    const h = Math.floor(m/60);
    return `${h}h ${m%60}m`;
  }

  // -----------------------
  // Energy helpers (robust offline/hidden auto-refill)
  // -----------------------
  function setEnergy(value, setTimestamp=true){
    try {
      const clamped = Math.max(0, Math.min(100, Math.round(Number(value) || 0)));
      const prev = Number(clientState.energy || 0);
      clientState.energy = clamped;
      if (setTimestamp) clientState.energyLastUpdatedAt = Date.now();
      if (clamped !== prev) {
        logAction('energy_set', { from: prev, to: clamped });
        saveClientToStorage();
        updateUI();
      } else {
        if (setTimestamp) saveClientToStorage();
      }
    } catch(e){ console.warn('setEnergy error', e); }
  }

  function applyOfflineEnergyRecharge(){
    try {
      if (typeof clientState.energy !== 'number') clientState.energy = 100;
      const last = Number(clientState.energyLastUpdatedAt || Date.now());
      const now = Date.now();
      const safeLast = last > now ? now : last;
      const elapsed = Math.max(0, now - safeLast);
      const perMs = AUTO_RECHARGE_MINUTES * 60e3;
      const increments = Math.floor(elapsed / perMs);
      if (increments > 0){
        const add = increments * AUTO_RECHARGE_PERCENT;
        const newEnergy = Math.min(100, (clientState.energy || 0) + add);
        clientState.energyLastUpdatedAt = safeLast + increments * perMs;
        clientState.energy = newEnergy;
        logAction('offline_recharge', { increments, add, energy: clientState.energy });
        saveClientToStorage();
        updateUI();
      } else {
        if (!clientState.energyLastUpdatedAt) {
          clientState.energyLastUpdatedAt = now;
          saveClientToStorage();
        }
      }
    } catch(e){ console.warn('applyOfflineEnergyRecharge error', e); }
  }

  function doAutoRechargeTick(){
    try {
      applyOfflineEnergyRecharge();
      setEnergy((clientState.energy || 0) + AUTO_RECHARGE_PERCENT, true);
      logAction('auto_recharge_tick', { energy: clientState.energy });
      attemptResumeAfterEnergy();
      sendState('auto_recharge', { energy: clientState.energy });
    } catch(e){ console.warn('doAutoRechargeTick error', e); }
  }

  // -----------------------
  // Ad / sitting helpers (REVISED)
  // -----------------------
  function resetDailyAdsIfNeeded(){
    try {
      const today = isoDateStr();
      if (!clientState.adsTodayDate || clientState.adsTodayDate !== today){
        clientState.adsTodayDate = today;
        clientState.adsToday = 0;
        clientState.sittingsUsedToday = 0;
        if (clientState.adsThisSittingStartedAt && (Date.now() - clientState.adsThisSittingStartedAt) >= SITTING_COOLDOWN_MS){
          clientState.adsThisSitting = 0;
          clientState.adsThisSittingStartedAt = null;
        }
        saveClientToStorage();
        updateUI();
      }
    } catch(e){ console.warn('resetDailyAdsIfNeeded', e); }
  }

  function normalizeAdStateOnLoad(){
    try {
      const today = isoDateStr();
      if (!clientState.adsTodayDate){
        clientState.adsTodayDate = today;
      }
      if (clientState.adsTodayDate !== today){
        clientState.adsTodayDate = today;
        clientState.adsToday = 0;
        clientState.sittingsUsedToday = 0;
        clientState.adsThisSitting = 0;
        clientState.adsThisSittingStartedAt = null;
        saveClientToStorage();
      } else {
        if (clientState.adsThisSittingStartedAt){
          if ((Date.now() - clientState.adsThisSittingStartedAt) >= SITTING_COOLDOWN_MS){
            clientState.adsThisSitting = 0;
            clientState.adsThisSittingStartedAt = null;
            saveClientToStorage();
          }
        }
      }
      updateUI();
    } catch(e){ console.warn('normalizeAdStateOnLoad failed', e); }
  }

  function sittingsRemainingToday(){
    return Math.max(0, (MAX_SITTINGS_PER_DAY - (clientState.sittingsUsedToday || 0)));
  }

  function timeUntilNextSittingAvailable(){
    if ((clientState.sittingsUsedToday || 0) >= MAX_SITTINGS_PER_DAY){
      return msUntilNextLocalMidnight();
    }
    if ((clientState.adsThisSitting || 0) < MAX_ADS_PER_SITTING){
      return 0;
    }
    if (clientState.adsThisSittingStartedAt){
      const elapsed = Date.now() - clientState.adsThisSittingStartedAt;
      const rem = Math.max(0, SITTING_COOLDOWN_MS - elapsed);
      return rem;
    }
    return 0;
  }

  function canWatchAd(){
    resetDailyAdsIfNeeded();
    if ((clientState.adsToday || 0) >= MAX_ADS_PER_DAY) return false;
    return timeUntilNextSittingAvailable() === 0;
  }

  function startSittingIfNeeded(){
    if (!clientState.adsThisSittingStartedAt || clientState.adsThisSittingStartedAt === null){
      clientState.adsThisSittingStartedAt = Date.now();
    }
  }

  function finishSittingAndConsume(){
    clientState.sittingsUsedToday = (clientState.sittingsUsedToday || 0) + 1;
    saveClientToStorage();
  }

  // -----------------------
  // Utilities: API and UI (with GP/Score delta sync)
  // -----------------------
  async function api(path, method='GET', body=null, optsExtra={}){
    try{
      let url = API_BASE + path;
      const sid = clientState.sessionId ? encodeURIComponent(clientState.sessionId) : '';
      if (method.toUpperCase() === 'GET' && sid){
        if (!url.includes('sessionId=')) url += (url.includes('?') ? '&' : '?') + 'sessionId=' + sid;
      }
      const headers = Object.assign({ 'Content-Type': 'application/json' }, optsExtra.headers || {});
      if (clientState.sessionId) headers['X-Session-Id'] = clientState.sessionId;
      const userHandle = clientState.username ? clientState.username : (clientState.telegramId ? ('tg_' + clientState.telegramId) : null);
      if (userHandle) headers['X-User-Handle'] = userHandle;

      const fetchOpts = { method, headers, ...optsExtra };
      if (body !== null && body !== undefined){
        if (typeof body === 'object' && !Array.isArray(body)){
          body.username = body.username || clientState.username || null;
          body.telegramId = body.telegramId || clientState.telegramId || null;
          body.sessionId = body.sessionId || clientState.sessionId || null;
          fetchOpts.body = JSON.stringify(body);
        } else {
          fetchOpts.body = body;
        }
      }

      const res = await fetch(url, fetchOpts);
      const text = await res.text();
      let json = null;
      try { json = text ? JSON.parse(text) : null; } catch(err) { json = text || null; }
      if (!res.ok) { console.warn('API non-ok', res.status, path, json); return json; }
      return json;
    } catch(e){ console.warn('API error', e); return null; }
  }

  // -----------------------
  // HXN-specific helpers (new)
  // -----------------------

  // Fetch authoritative HXN balance and credits (calls GET /hxn/balance)
  async function fetchHxnBalance(){
    try {
      const resp = await api('/hxn/balance','GET');
      if (resp && resp.ok){
        clientState.hxnBalance = resp.balance != null ? String(resp.balance) : null;
        clientState.hxnCredits = resp.credits != null ? String(resp.credits) : null;
        // server also returns userAU/totalAU via other endpoints; we will keep consistent on init/sync
        updateUI();
        saveClientToStorage();
        return resp;
      } else {
        // keep existing state but update UI
        updateUI();
        return resp;
      }
    } catch(e){ console.warn('fetchHxnBalance error', e); updateUI(); return null; }
  }

  // Sync mining for the authenticated user. Calls POST /hxn/sync to credit newly mined HXN since last mined ledger entry.
  // Returns server response which includes earnedHXN, userAU and totalAU.
  async function syncHxnMining(){
    try {
      showToast('Syncing mining…', 1200);
      const resp = await api('/hxn/sync','POST', { sessionId: clientState.sessionId });
      if (resp && resp.ok){
        // update local AU totals returned by server
        if (typeof resp.userAU !== 'undefined') clientState.userAU = Number(resp.userAU || 0);
        if (typeof resp.totalAU !== 'undefined') clientState.totalAU = Number(resp.totalAU || 0);
        // server returns earnedHXN as string
        if (typeof resp.earnedHXN !== 'undefined') {
          const earned = resp.earnedHXN;
          showSheet({ title: 'Mining Sync', bodyHtml: `<div class="small-muted">Synced mining — newly credited: <b>${escapeHtml(String(earned))} HXN</b></div>` , actionsHtml:`<button id="syncClose" class="btn-ghost">Close</button>` , onMounted: ()=> { const c = $('syncClose'); if (c) c.onclick = hideSheet; }});
        } else {
          showToast('Sync complete', 1000);
        }
        // fetch fresh balance (ledger may have been updated)
        await fetchHxnBalance();
        saveClientToStorage();
        updateUI();
        return resp;
      } else {
        showToast('Sync failed', 1200);
        return resp;
      }
    } catch(e){ console.warn('syncHxnMining error', e); showToast('Sync error',1200); return null; }
  }

  // Convert numeric or string values to a pretty-localized HXN display
  function prettyHxn(v){
    if (v === null || typeof v === 'undefined') return '—';
    try {
      // try to keep up to 6 fractional digits when necessary
      const n = Number(v);
      if (!isFinite(n)) return String(v);
      if (Math.abs(n) < 1) return n.toFixed(6).replace(/\.?0+$/,'');
      if (n < 1000) return n.toLocaleString(undefined, { maximumFractionDigits: 6 });
      return n.toLocaleString(undefined, { maximumFractionDigits: 2 });
    } catch(e){ return String(v); }
  }

  // -----------------------
  // Telegram init
  // -----------------------
  function initTelegram(){
    try {
      if (window.Telegram && window.Telegram.WebApp){
        const tg = window.Telegram.WebApp;
        try{ if (typeof tg.ready === 'function') tg.ready(); } catch(e){}
        try { if (typeof tg.expand === 'function') tg.expand(); } catch(e){}
        const u = (tg.initDataUnsafe && tg.initDataUnsafe.user) || (tg.initData && tg.initData.user) || null;
        if (u){
          clientState.telegramId = u.id || clientState.telegramId;
          clientState.username = clientState.username || (u.username || `${u.first_name || ''} ${u.last_name || ''}`.trim() || null);
          if (clientState.username) updateUI();
        }
      }
    } catch(e){ console.warn('initTelegram error', e); }
  }

  // -----------------------
  // UI helpers
  // -----------------------
  function getRefFromURL(){ try{ const params = new URLSearchParams(window.location.search); return params.get('ref') || params.get('refCode') || null; } catch(e){ return null; } }
  function savePendingReferral(code){ if (!code) return; try{ localStorage.setItem(STORAGE_KEYS.PENDING_REF, code); clientState.pendingReferral = code; saveClientToStorage(); } catch(e){} }
  function loadPendingReferral(){ try{ const code = localStorage.getItem(STORAGE_KEYS.PENDING_REF); clientState.pendingReferral = code || null; return clientState.pendingReferral; } catch(e){ return null; } }
  function clearPendingReferral(){ try{ localStorage.removeItem(STORAGE_KEYS.PENDING_REF); clientState.pendingReferral = null; saveClientToStorage(); } catch(e){} }

  function showToast(msg, ms=2000){ const el = $('toast'); if(!el) return; el.textContent = msg; el.style.display = 'block'; setTimeout(()=> el.style.display='none', ms); }
  function renderMinersList(){ const container = $('minersList'); if (!container) return; container.innerHTML=''; if (!clientState.miners || clientState.miners.length===0){ container.innerHTML='<div class="small-muted">No miners owned</div>'; return; } clientState.miners.forEach(m=>{ const node = document.createElement('div'); node.style.display='flex'; node.style.justifyContent='space-between'; node.style.padding='6px 0'; node.innerHTML = `<div><b>${escapeHtml(m.name)}</b><div class="small-muted">Hash ${escapeHtml(String(m.au))} AU</div></div><div class="small-muted">${escapeHtml(m.status||'Active')}</div>`; container.appendChild(node); }); }

  async function refreshLeaderboard(){ const top = await api('/leaderboard/top','GET'); const el = $('leaderboard'); if (!el) return; el.innerHTML=''; if (!top || !Array.isArray(top)){ el.innerHTML = '<div class="small-muted">Leaderboard unavailable</div>'; return; } top.forEach((t,idx)=>{ const row = document.createElement('div'); row.className='leader-entry'; row.style.display='flex'; row.style.justifyContent='space-between'; row.style.padding='6px 0'; row.innerHTML = `<div>${idx+1}. ${escapeHtml(t.name || '—')}</div><div>${(t.score!=null)?Number(t.score).toLocaleString():'—'}</div>`; el.appendChild(row); }); }

  function derivedGPFromScore(score){ return Math.floor((score || 0) / 150); }
  function computeDisplayedGP(){ const base = Number(clientState.gpBase || 0); const derived = derivedGPFromScore(gameState.score || 0); return base + derived; }

  function updateUI(){
    if ($('ui-score')) {
      const server = (clientState.serverScore != null) ? Number(clientState.serverScore).toLocaleString() : '—';
      $('ui-score').innerHTML = `${(gameState.score || 0).toLocaleString()} <div class="small-muted" style="margin-top:4px;">server: ${server}</div>`;
    }
    if ($('ui-gp')) {
      const total = computeDisplayedGP();
      $('ui-gp').innerText = total.toLocaleString() + ' GP';
    }
    if ($('ui-gp-server')) {
      $('ui-gp-server').innerText = 'server: ' + (Number(clientState.gpBase || 0).toLocaleString()) + ' GP';
    }
    if ($('ui-energyFill') && $('ui-energyFill').style) $('ui-energyFill').style.width = Math.max(0, Math.min(100, clientState.energy||0)) + '%';
    if ($('ui-level')) $('ui-level').innerText = gameState.level;
    if ($('ui-lines')) $('ui-lines').innerText = gameState.lines;
    if ($('ui-au')) $('ui-au').innerText = 'AU: ' + (clientState.userAU||0).toFixed(2);
    if ($('ui-total-au')) $('ui-total-au').innerText = 'total AU: ' + (clientState.totalAU||0);

    // HXN display: prefer server balance if available, otherwise show estimate by AU share
    const hxnEl = $('ui-hxn');
    const hxnSub = $('ui-hxn-sub');
    let displayedHXN = '— HXN';
    if (clientState.hxnBalance != null){
      displayedHXN = prettyHxn(clientState.hxnBalance) + ' HXN';
      if (hxnSub){
        hxnSub.innerHTML = `ledger credits: ${clientState.hxnCredits ? prettyHxn(clientState.hxnCredits) + ' HXN' : '—'} • preview/day: ${computeHxnPreviewPerDay()}`;
      }
    } else {
      // fallback preview based on AU share
      const preview = computeHxnPreviewPerDay();
      displayedHXN = `${preview} HXN (preview)`;
      if (hxnSub) hxnSub.innerHTML = 'server balance unavailable — showing estimate by AU share';
    }
    if (hxnEl) hxnEl.innerText = displayedHXN;

    if ($('ui-username')) { $('ui-username').innerText = clientState.username ? `@${clientState.username}` : (clientState.userId ? `user:${clientState.userId}` : 'Guest'); }
    if ($('ui-session')) { $('ui-session').innerText = clientState.sessionId || '—'; }
    if ($('ui-wallet')) { $('ui-wallet').innerText = clientState.wallet ? clientState.wallet : 'Not connected'; }
    if ($('ui-provider')) { $('ui-provider').innerText = clientState.walletProvider ? clientState.walletProvider : '—'; }
    if ($('ui-adsToday')) $('ui-adsToday').innerText = String(clientState.adsToday||0);
    if ($('ui-sittings')) $('ui-sittings').innerText = `${sittingsRemainingToday()}/${MAX_SITTINGS_PER_DAY}`;
  }

  function computeHxnPreviewPerDay(){
    try {
      const userAU = Number(clientState.userAU || 0);
      const totalAU = Number(clientState.totalAU || 0);
      if (!totalAU || totalAU <= 0) return '—';
      const share = (userAU / totalAU) * DAILY_EMISSION_CAP;
      return Math.round(share).toLocaleString() + '';
    } catch(e){ return '—'; }
  }

  // -----------------------
  // Pieces & core logic (unchanged)
  // -----------------------
  const PIECES = {
    I: [[[0,1],[1,1],[2,1],[3,1]], [[2,0],[2,1],[2,2],[2,3]], [[0,2],[1,2],[2,2],[3,2]], [[1,0],[1,1],[1,2],[1,3]]],
    J: [[[0,0],[0,1],[1,1],[2,1]], [[1,0],[2,0],[1,1],[1,2]], [[0,1],[1,1],[2,1],[2,2]], [[1,0],[1,1],[0,2],[1,2]]],
    L: [[[2,0],[0,1],[1,1],[2,1]], [[1,0],[1,1],[1,2],[2,2]], [[0,1],[1,1],[2,1],[0,2]], [[0,0],[1,0],[1,1],[1,2]]],
    O: [[[1,0],[2,0],[1,1],[2,1]]],
    S: [[[1,0],[2,0],[0,1],[1,1]], [[1,0],[1,1],[2,1],[2,2]]],
    T: [[[1,0],[0,1],[1,1],[2,1]], [[1,0],[1,1],[2,1],[1,2]], [[0,1],[1,1],[2,1],[1,2]], [[1,0],[0,1],[1,1],[1,2]]],
    Z: [[[0,0],[1,0],[1,1],[2,1]], [[2,0],[1,1],[2,1],[1,2]]]
  };
  const PIECE_TYPES = Object.keys(PIECES);

  let phaserGame;
  let CELL = BASE_CELL, GAP = BASE_GAP;

  function gridPixelSize(cols, rows){
    const width = cols * CELL + Math.max(0, cols - 1) * GAP;
    const height = rows * CELL + Math.max(0, rows - 1) * GAP;
    return { width, height };
  }

  // -----------------------
  // Real-time REST sync (throttled sends, now sending deltas)
  // -----------------------
  const SEND_THROTTLE_MS = 400;
  let lastSendAt = 0;
  let pendingSendTimer = null;

  function buildStatePayload(eventType='heartbeat', extra={}){
    const displayedGP = computeDisplayedGP();
    const lastSentGp = Number((clientState.lastSent && clientState.lastSent.gpTotal) || 0);
    const gpDelta = displayedGP - lastSentGp;

    const displayedScore = Number(gameState.score || 0);
    const lastSentScore = Number((clientState.lastSent && clientState.lastSent.score) || 0);
    const scoreDelta = displayedScore - lastSentScore;

    const base = {
      sessionId: clientState.sessionId,
      event: eventType,
      partial: eventType !== 'final',
      score: gameState.score,
      lines: gameState.lines,
      level: gameState.level,
      dropInterval: gameState.dropInterval,
      energy: clientState.energy,
      activePiece: gameState.activePiece || null,
      nextPiece: gameState.nextPiece || null,
      actionLog: (clientState.actionLog || []).slice(-200),
      ts: Date.now(),
      gpDelta: gpDelta !== 0 ? gpDelta : 0,
      scoreDelta: scoreDelta !== 0 ? scoreDelta : 0,
      gpTotalClient: displayedGP,
      scoreTotalClient: displayedScore
    };

    return Object.assign({}, base, extra);
  }

  async function sendState(eventType='heartbeat', extra={}){
    try {
      const now = Date.now();
      const sinceLast = now - lastSendAt;
      const payload = buildStatePayload(eventType, extra);
      if (sinceLast < SEND_THROTTLE_MS){
        if (pendingSendTimer) clearTimeout(pendingSendTimer);
        pendingSendTimer = setTimeout(()=> { pendingSendTimer = null; doSend(payload); }, SEND_THROTTLE_MS - sinceLast + 10);
        return;
      }
      await doSend(payload);
    } catch(e){ console.warn('sendState error', e); }
  }

  async function doSend(payload){
    try {
      lastSendAt = Date.now();
      const res = await api('/game/submit-score','POST', payload);
      if (res){
        if (typeof res.gp !== 'undefined'){
          clientState.gpBase = Number(res.gp || 0);
          clientState.lastSent = clientState.lastSent || {};
          clientState.lastSent.gpTotal = Number(clientState.gpBase);
        } else {
          if (payload.gpDelta && payload.gpDelta !== 0){
            clientState.lastSent = clientState.lastSent || {};
            clientState.lastSent.gpTotal = Number((clientState.lastSent.gpTotal || 0) + payload.gpDelta);
          }
        }

        if (typeof res.score !== 'undefined'){
          clientState.serverScore = Number(res.score || 0);
          clientState.lastSent = clientState.lastSent || {};
          clientState.lastSent.score = Number(clientState.serverScore);
        } else {
          if (payload.scoreDelta && payload.scoreDelta !== 0){
            clientState.lastSent = clientState.lastSent || {};
            clientState.lastSent.score = Number((clientState.lastSent.score || 0) + payload.scoreDelta);
          }
        }

        if (typeof res.userAU !== 'undefined') clientState.userAU = res.userAU;
        if (typeof res.totalAU !== 'undefined') clientState.totalAU = res.totalAU;
        if (typeof res.miners !== 'undefined') clientState.miners = res.miners;
        if (typeof res.wallet !== 'undefined') clientState.wallet = res.wallet;
        if (typeof res.sessionId !== 'undefined' && res.sessionId !== clientState.sessionId) {
          clientState.sessionId = res.sessionId;
          saveSessionToStorage(clientState.sessionId);
        }

        saveClientToStorage();
        updateUI();
      }
    } catch(e){ console.warn('doSend error', e); }
  }

  // heartbeat while playing
  setInterval(()=> { if (!gameState.isPlaying) return; sendState('heartbeat'); }, 2000);

  // -----------------------
  // Phaser scenes (copied from your existing code)
  // -----------------------
  class BootScene extends Phaser.Scene { constructor(){ super({ key:'BootScene' }); } create(){ this.scene.start('GameScene'); } }

  class GameScene extends Phaser.Scene {
    constructor(){ super({ key:'GameScene' }); this.cellSprites = null; this.g = null; this.dropEvent = null; this._gestureBound = false; this._dropPaused = false; }
    create(){
      const gridSize = gridPixelSize(GRID_COLS, GRID_ROWS);
      this.boardPixelWidth = gridSize.width + BOARD_PADDING * 2;
      this.boardPixelHeight = gridSize.height + BOARD_PADDING * 2;
      this.gridOrigin = { x: BOARD_PADDING, y: BOARD_PADDING };
      this.g = this.add.graphics();
      this.drawBoard();
      if (!gameState.grid) initGrid();
      if (!gameState.activePiece) spawnPiece();
      this.rebuildCellSprites();
      gameState.isPlaying = gameState.isPlaying !== undefined ? gameState.isPlaying : true;
      updateUI();
      this.catchUpMissedTicks();

      const scene = this;
      if (gameState.isPlaying){
        if (gameState.tickRemaining && Number.isFinite(gameState.tickRemaining) && gameState.tickRemaining > 0){
          scene.startDropLoop(gameState.tickRemaining);
        } else {
          scene.startDropLoop();
        }
      }

      this.setupInput();
      this.time.addEvent({ delay: AUTO_RECHARGE_MINUTES * 60e3, callback: doAutoRechargeTick, callbackScope: this, loop: true });

      this.saveStateTimer = this.time.addEvent({
        delay: 2000,
        loop: true,
        callback: () => {
          gameState.lastSavedAt = Date.now();
          saveGameToStorage();
          saveClientToStorage();
        }
      });
    }

    drawBoard(){
      try {
        if (this.g) { this.g.clear(); }
        const g = this.g;
        g.fillStyle(0x061426,1);
        g.fillRoundedRect(this.gridOrigin.x -8, this.gridOrigin.y -8, this.boardPixelWidth, this.boardPixelHeight, 10);

        const totalW = GRID_COLS * CELL + Math.max(0, GRID_COLS - 1) * GAP;
        const totalH = GRID_ROWS * CELL + Math.max(0, GRID_ROWS - 1) * GAP;

        g.lineStyle(1, 0x0d2130, 0.6);
        for (let r=0; r<=GRID_ROWS; r++){
          const yy = this.gridOrigin.y + r * (CELL + GAP);
          g.strokeLineShape(new Phaser.Geom.Line(this.gridOrigin.x, yy, this.gridOrigin.x + totalW, yy));
        }
        for (let c=0; c<=GRID_COLS; c++){
          const xx = this.gridOrigin.x + c * (CELL + GAP);
          g.strokeLineShape(new Phaser.Geom.Line(xx, this.gridOrigin.y, xx, this.gridOrigin.y + totalH));
        }
      } catch(e){ console.warn('drawBoard error', e); }
    }

    rebuildCellSprites(){
      try {
        if (this.cellSprites && Array.isArray(this.cellSprites)){
          for (let r=0; r<this.cellSprites.length; r++){
            for (let c=0; c<(this.cellSprites[r] || []).length; c++){
              const obj = this.cellSprites[r][c];
              if (obj && typeof obj.destroy === 'function') obj.destroy();
            }
          }
        }
      } catch(e){ console.warn('destroy old cellSprites failed', e); }
      this.cellSprites = Array.from({ length: GRID_ROWS }, () => Array(GRID_COLS).fill(null));

      for (let r=0;r<GRID_ROWS;r++){
        for (let c=0;c<GRID_COLS;c++){
          const x = this.gridOrigin.x + c * (CELL + GAP) + CELL/2;
          const y = this.gridOrigin.y + r * (CELL + GAP) + CELL/2;
          const rect = this.add.rectangle(x,y,CELL,CELL,0x102033).setStrokeStyle(1,0x092033,0.6);
          rect.updateFill = function(color){ try { if (typeof this.setFillStyle === 'function') this.setFillStyle(color); else this.fillColor = color; } catch(e) { try{ this.fillColor = color; }catch(_){} } };
          rect.setInteractive({ useHandCursor: true });
          ((rr,cc,node)=> node.on('pointerdown', ()=> { vibratePreferTelegram(); logAction('cell_click',{x:cc,y:rr}); const orig = node.fillColor || 0x102033; node.updateFill(0xFFFFFF); this.time.delayedCall(80, ()=> node.updateFill(orig)); }))(r,c,rect);
          this.cellSprites[r][c] = rect;
        }
      }
      this.renderGrid();
    }

    onResizeRebuild(){
      const gridSize = gridPixelSize(GRID_COLS, GRID_ROWS);
      this.boardPixelWidth = gridSize.width + BOARD_PADDING * 2;
      this.boardPixelHeight = gridSize.height + BOARD_PADDING * 2;
      this.gridOrigin = { x: BOARD_PADDING, y: BOARD_PADDING };
      this.drawBoard();
      this.rebuildCellSprites();
    }

    startDropLoop(initialDelay){
      try {
        if (this.dropEvent){ try{ this.dropEvent.remove(false); }catch(e){} this.dropEvent=null; }
        this._dropPaused = false;

        const di = Math.max(40, gameState.dropInterval || INITIAL_DROP_MS);

        if (Number.isFinite(initialDelay) && initialDelay > 0){
          this.dropEvent = this.time.delayedCall(initialDelay, () => {
            if (!gameState.isPlaying) return;
            const moved = movePieceDown();
            logAction('tick_drop',{ moved, resumed:true });
            sendState('tick', { moved, resumed:true });
            if (!moved) {
              lockPiece();
            }
            gameState.lastTickAt = Date.now();
            gameState.tickRemaining = null;
            saveGameToStorage();
            updateUI();
            try {
              if (this.dropEvent) { try{ this.dropEvent.remove(false); }catch(e){} this.dropEvent=null; }
              gameState.lastTickAt = Date.now();
              this.dropEvent = this.time.addEvent({ delay: di, loop: true, callback: () => {
                if (!gameState.isPlaying) return;
                const moved2 = movePieceDown();
                logAction('tick_drop',{ moved: moved2 });
                sendState('tick', { moved: moved2 });
                if (!moved2) lockPiece();
                gameState.lastTickAt = Date.now();
                saveGameToStorage();
                updateUI();
              }});
            } catch(err){
              console.warn('startDropLoop fallback failed', err);
            }
          }, [], this);
        } else {
          gameState.lastTickAt = Date.now();
          this.dropEvent = this.time.addEvent({ delay: di, loop: true, callback: ()=> {
            if (!gameState.isPlaying) return;
            const moved = movePieceDown();
            logAction('tick_drop',{ moved });
            sendState('tick', { moved });
            if (!moved) {
              lockPiece();
            }
            gameState.lastTickAt = Date.now();
            saveGameToStorage();
            updateUI();
          }});
        }
      } catch(e){ console.warn('startDropLoop error', e); }
    }

    pauseDropLoop(){
      try {
        if (this.dropEvent){
          try { this.dropEvent.paused = true; this._dropPaused = true; } catch(e){ this._dropPaused = false; }
        } else {
          this._dropPaused = false;
        }
      } catch(e){ console.warn('pauseDropLoop error', e); }
    }

    resumeDropLoop(initialDelay){
      try {
        if (this._dropPaused && this.dropEvent){
          try { this.dropEvent.paused = false; this._dropPaused = false; return; } catch(e){ /* fall through to recreate */ }
        }
        this.startDropLoop(initialDelay);
      } catch(e){ console.warn('resumeDropLoop error', e); }
    }

    update(){ if (!gameState.isPlaying) return; this.renderGrid(); }
    renderGrid(){
      for (let r=0;r<GRID_ROWS;r++){
        for (let c=0;c<GRID_COLS;c++){
          const val = (gameState.grid && gameState.grid[r]) ? gameState.grid[r][c] : 0;
          const color = val ? colorFromVal(val) : 0x102033;
          const rect = this.cellSprites[r][c];
          if (rect && typeof rect.updateFill === 'function') rect.updateFill(color);
        }
      }
      if (gameState.activePiece){
        const cells = getPieceCells(gameState.activePiece);
        cells.forEach(p => {
          if (p.y>=0 && p.y<GRID_ROWS && p.x>=0 && p.x<GRID_COLS){
            const rect = this.cellSprites[p.y][p.x];
            if (rect && typeof rect.updateFill === 'function') rect.updateFill(colorFromVal(gameState.activePiece.type));
          }
        });
      }
    }

    setupInput(){
      this.input.keyboard.on('keydown', (ev)=>{ if (!gameState.isPlaying) return; handleKey(ev.code || ev.key); });
      window.addEventListener('keydown', (ev)=>{ if (!gameState.isPlaying) return; handleKey(ev.code || ev.key); });
      setupTouchControls(this);

      if (!this._gestureBound){
        const el = document.getElementById('phaserCanvas');
        if (el){
          let startX = 0, startY = 0, startT = 0, moved = false;
          el.addEventListener('pointerdown', (e) => {
            try {
              startX = e.clientX;
              startY = e.clientY;
              startT = Date.now();
              moved = false;
            } catch(e){ console.warn('pointerdown gesture', e); }
          }, { passive: true });

          el.addEventListener('pointermove', (e) => {
            try {
              const dx = Math.abs(e.clientX - startX);
              const dy = Math.abs(e.clientY - startY);
              if (dx > TAP_MAX_MOV || dy > TAP_MAX_MOV) moved = true;
            } catch(e){ /* ignore */ }
          }, { passive: true });

          el.addEventListener('pointerup', (e) => {
            try {
              const dx = e.clientX - startX;
              const dy = e.clientY - startY;
              const dt = Date.now() - startT;
              if (!moved && Math.abs(dx) <= TAP_MAX_MOV && Math.abs(dy) <= TAP_MAX_MOV && dt <= TAP_MAX_TIME) {
                if (gameState.isPlaying) {
                  rotatePiece();
                  vibratePreferTelegram();
                  logAction('gesture_tap');
                  sendState('gesture_tap');
                  updateUI(); saveGameToStorage();
                }
                return;
              }
              if (Math.abs(dx) >= SWIPE_MIN_DIST && Math.abs(dx) > Math.abs(dy)) {
                if (dx < 0) {
                  movePiece(-1);
                  vibratePreferTelegram();
                  logAction('gesture_swipe_left_moved_left');
                  sendState('gesture_swipe_left_moved_left');
                } else {
                  movePiece(1);
                  vibratePreferTelegram();
                  logAction('gesture_swipe_right_moved_right');
                  sendState('gesture_swipe_right_moved_right');
                }
                updateUI(); saveGameToStorage();
                return;
              }
              if (Math.abs(dy) >= SWIPE_MIN_DIST && Math.abs(dy) > Math.abs(dx)) {
                if (dy > 0) {
                  softDrop();
                  vibratePreferTelegram();
                  logAction('gesture_swipe_down_softdrop');
                  sendState('gesture_swipe_down_softdrop');
                  updateUI(); saveGameToStorage();
                }
                return;
              }
            } catch(err){ console.warn('pointerup error', err); }
          }, { passive: true });

          el.addEventListener('touchstart', function(){}, { passive: true });

          this._gestureBound = true;
        }
      }
    }

    autoRecharge(){ doAutoRechargeTick(); }

    catchUpMissedTicks(){
      try {
        if (gameState.hiddenAt) {
          return;
        }
        if (!gameState.lastTickAt || !gameState.isPlaying) return;
        const now = Date.now();
        const elapsed = Math.max(0, now - gameState.lastTickAt);
        const di = Math.max(40, gameState.dropInterval || INITIAL_DROP_MS);
        const ticks = Math.floor(elapsed / di);
        if (!ticks) return;
        for (let i=0;i<ticks;i++){
          if (!gameState.isPlaying) break;
          const moved = movePieceDown();
          if (!moved){
            lockPiece();
            if (!gameState.isPlaying) break;
          }
        }
        gameState.lastTickAt = now;
        saveGameToStorage();
      } catch(e){ console.warn('catchUpMissedTicks error', e); }
    }
  }

  // -----------------------
  // Game functions (unchanged)
  // -----------------------
  function handleKey(code){ switch(code){ case 'ArrowLeft': case 'Left': movePiece(-1); break; case 'ArrowRight': case 'Right': movePiece(1); break; case 'ArrowDown': case 'Down': softDrop(); break; case 'Space': case ' ': hardDrop(); break; case 'ArrowUp': case 'Up': rotatePiece(); break; default: return; } updateUI(); saveGameToStorage(); saveClientToStorage(); }

  function getPieceCells(piece){
    if(!piece || !piece.type) return [];
    const states = PIECES[piece.type];
    if (!states || !Array.isArray(states) || states.length === 0) return [];
    const rotRaw = Number.isFinite(piece.rot) ? piece.rot : 0;
    const rotIndex = ((Math.floor(rotRaw) % states.length) + states.length) % states.length;
    const state = states[rotIndex];
    if (!Array.isArray(state)) return [];
    return state.map(p => ({ x: (p[0] + (piece.x||0)), y: (p[1] + (piece.y||0)) }));
  }

  function initGrid(){ gameState.grid = Array.from({ length: GRID_ROWS }, ()=> Array(GRID_COLS).fill(0)); gameState.score = 0; gameState.level = 1; gameState.lines = 0; gameState.combo = 0; gameState.dropInterval = INITIAL_DROP_MS; gameState.isPlaying = true; gameState.lastSavedAt = Date.now(); gameState.lastTickAt = Date.now(); gameState.pausedForEnergy = false; gameState.tickRemaining = null; saveGameToStorage(); sendState('init'); }

  function getSpawnYOffset(type){ if (type === 'I') return -2; return -1; }

  function spawnPiece(){
    if ((clientState.energy||0) <= 0){
      try {
        const now = Date.now();
        if (gameState.lastTickAt && Number.isFinite(gameState.dropInterval)){
          const di = Math.max(40, gameState.dropInterval || INITIAL_DROP_MS);
          const elapsed = Math.max(0, now - gameState.lastTickAt);
          gameState.tickRemaining = ((di - (elapsed % di)) + di) % di || di;
        } catch(e){ gameState.tickRemaining = gameState.dropInterval || INITIAL_DROP_MS; }
      } catch(e){ gameState.tickRemaining = gameState.dropInterval || INITIAL_DROP_MS; }
      gameState.pausedForEnergy = true;
      gameState.isPlaying = false;
      gameState.activePiece = null;
      showSheet({ title:'Energy', bodyHtml:'<div class="small-muted">Out of energy — watch an ad or wait for recharge.</div>' });
      saveGameToStorage();
      return;
    }
    const type = PIECE_TYPES[Math.floor(Math.random()*PIECE_TYPES.length)];
    const xStart = Math.floor((GRID_COLS - 4)/2);
    const yStart = getSpawnYOffset(type);
    gameState.activePiece = { type, rot:0, x:xStart, y:yStart };
    gameState.nextPiece = PIECE_TYPES[Math.floor(Math.random()*PIECE_TYPES.length)];
    logAction('spawn',{ type, x:xStart, y:yStart });
    sendState('spawn', { spawnedType: type, xStart, yStart });
    if (checkCollision(getPieceCells(gameState.activePiece))) {
      gameOver();
    } else {
      gameState.lastTickAt = Date.now();
      saveGameToStorage();
    }
  }

  function checkCollision(cells){ for (const p of cells){ if (p.x < 0 || p.x >= GRID_COLS) return true; if (p.y >= GRID_ROWS) return true; if (p.y >= 0 && gameState.grid[p.y][p.x]) return true; } return false; }

  function movePiece(dir){ if (!gameState.activePiece) return; const cand = { ...gameState.activePiece, x: gameState.activePiece.x + dir }; if (!checkCollision(getPieceCells(cand))){ gameState.activePiece.x = cand.x; logAction('move',{ dir }); sendState('move',{dir}); saveGameToStorage(); } }

  function movePieceDown(){ if (!gameState.activePiece) return false; const cand = { ...gameState.activePiece, y: gameState.activePiece.y + 1 }; if (!checkCollision(getPieceCells(cand))){ gameState.activePiece.y = cand.y; return true; } return false; }

  function softDrop(){ if (movePieceDown()){ gameState.score += 1; logAction('soft_drop'); sendState('soft_drop'); updateUI(); saveGameToStorage(); } }

  function hardDrop(){ let falls=0; while(movePieceDown()) falls++; lockPiece(); gameState.score += falls * 2; logAction('hard_drop',{ falls }); sendState('hard_drop',{ falls }); updateUI(); saveGameToStorage(); }

  function rotatePiece(){
    if (!gameState.activePiece) return;
    const type = gameState.activePiece.type;
    const states = PIECES[type];
    if (!states || states.length <= 1) return;
    const currentRot = Number.isFinite(gameState.activePiece.rot) ? Math.floor(gameState.activePiece.rot) : 0;
    const newRot = (currentRot + 1) % states.length;
    const kicks = [{dx:0,dy:0},{dx:-1,dy:0},{dx:1,dy:0},{dx:0,dy:-1},{dx:-2,dy:0},{dx:2,dy:0}];
    for (const k of kicks){
      const cand = { ...gameState.activePiece, rot: newRot, x: gameState.activePiece.x + k.dx, y: gameState.activePiece.y + k.dy };
      if (!checkCollision(getPieceCells(cand))){
        gameState.activePiece.rot = ((newRot % states.length) + states.length) % states.length;
        gameState.activePiece.x = cand.x;
        gameState.activePiece.y = cand.y;
        logAction('rotate',{ rot:gameState.activePiece.rot, kick:k });
        sendState('rotate',{ rot:gameState.activePiece.rot, kick:k });
        saveGameToStorage();
        return;
      }
    }
  }

  function lockPiece(){
    const ap = gameState.activePiece; if (!ap) return;
    const cells = getPieceCells(ap);
    for (const p of cells){ if (p.y >= 0 && p.y < GRID_ROWS && p.x >= 0 && p.x < GRID_COLS){ gameState.grid[p.y][p.x] = ap.type; } }
    setEnergy((clientState.energy || 0) - 1, true);
    const cleared = [];
    for (let r=0;r<GRID_ROWS;r++) if (gameState.grid[r].every(v=>v!==0)) cleared.push(r);
    if (cleared.length > 0) clearLines(cleared); else gameState.combo = 0;
    gameState.activePiece = null;
    sendState('lock', { lockedPiece: ap, cleared });
    spawnPiece();
    try{ const scene = phaserGame && phaserGame.scene && phaserGame.scene.keys && phaserGame.scene.keys.GameScene; if (scene && typeof scene.startDropLoop === 'function') scene.startDropLoop(); }catch(e){}
    saveClientToStorage();
    saveGameToStorage();
    updateUI();
  }

  function clearLines(rows){
    rows.sort((a,b)=>a-b);
    for (const r of rows){ gameState.grid.splice(r,1); gameState.grid.unshift(Array(GRID_COLS).fill(0)); }
    const count = rows.length; const base = [0,100,300,500,800];
    gameState.score += base[count] * gameState.level;
    gameState.lines += count; gameState.combo += 1;
    logAction('clear',{ count, combo:gameState.combo });
    sendState('clear',{ count, combo: gameState.combo, clearedRows: rows });
    if (gameState.lines % 10 === 0){ gameState.level++; gameState.dropInterval = Math.max(120, Math.floor(gameState.dropInterval * 0.92)); }
    saveGameToStorage();
    updateUI();
  }

  async function gameOver(){
    if (!gameState.isPlaying) return;
    gameState.isPlaying = false;
    logAction('gameover',{ score:gameState.score, lines:gameState.lines });

    try{
      const finalPayload = buildStatePayload('final', {
        partial: false,
        finalSubmission: true,
        actionLog: (clientState.actionLog || []).slice(-2000)
      });

      const res = await api('/game/submit-score','POST', finalPayload);

      if (res){
        if (typeof res.gp !== 'undefined'){
          clientState.gpBase = Number(res.gp || 0);
          clientState.lastSent = clientState.lastSent || {};
          clientState.lastSent.gpTotal = Number(clientState.gpBase);
        }
        if (typeof res.score !== 'undefined'){
          clientState.serverScore = Number(res.score || 0);
          clientState.lastSent = clientState.lastSent || {};
          clientState.lastSent.score = Number(clientState.serverScore);
        }
        if (typeof res.userAU !== 'undefined') clientState.userAU = res.userAU;
        if (typeof res.totalAU !== 'undefined') clientState.totalAU = res.totalAU;
        saveClientToStorage();
      }
    } catch(e){ console.warn(e); }

    showSheet({ title:'Game Over', bodyHtml:`<div style="font-weight:700">Game Over</div><div class="small-muted">Score ${gameState.score} • Lines ${gameState.lines}</div>`, actionsHtml:`<button id="playAgain" class="button"><i class="fa-solid fa-rotate"></i> Play Again</button><button id="closeOver" class="btn-ghost">Close</button>`, onMounted: ()=>{ const p=$('playAgain'); if (p) p.onclick = ()=> { hideSheet(); resetForPlay(); }; const c=$('closeOver'); if (c) c.onclick=hideSheet; }});
    saveGameToStorage();
    saveClientToStorage();
    updateUI();
  }

  function resetForPlay(){
    initGrid();
    gameState.dropInterval = INITIAL_DROP_MS;
    clientState.actionLog = [];
    clientState.energy = Math.max(0, clientState.energy);
    spawnPiece();
    gameState.isPlaying = true;
    gameState.pausedForEnergy = false;
    gameState.tickRemaining = null;
    clearSavedGame();
    saveClientToStorage();
    updateUI();
    try{ const scene = phaserGame && phaserGame.scene && phaserGame.scene.keys && phaserGame.scene.keys.GameScene; if (scene && typeof scene.startDropLoop === 'function') scene.startDropLoop(); }catch(e){}
  }

  function colorFromVal(val){ const map = { I:0x22d3ee, J:0x7c3aed, L:0xf59e0b, O:0xfacc15, S:0x10b981, T:0x8b5cf6, Z:0xef4444 }; return map[val] ?? 0x0f172a; }

  // -----------------------
  // Touch controls wiring (no on-screen buttons — gestures handle everything)
  // -----------------------
  function setupTouchControls(scene){
    // intentionally minimal: gestures are on the canvas
  }

  function vibratePreferTelegram(){ try{ const tg = (window.Telegram && window.Telegram.WebApp) ? window.Telegram.WebApp : null; if (tg && typeof tg.triggerHapticFeedback === 'function'){ tg.triggerHapticFeedback('selection_change'); return; } }catch(e){} if (navigator && typeof navigator.vibrate === 'function') navigator.vibrate(20); }

  // -----------------------
  // Wallet + deep link code (unchanged, except we ensure lastSent markers set on bind)
  // -----------------------
  function detectInjectedProviders(){
    const solana = window.solana || null;
    return {
      phantom: Boolean((solana && solana.isPhantom) || (window.phantom && window.phantom.isPhantom)),
      solflare: Boolean(window.solflare || (solana && solana.isSolflare)),
      backpack: Boolean(window.backpack || (solana && solana.isBackpack)),
      anySolana: Boolean(solana || window.solflare || window.backpack || window.phantom)
    };
  }

  function setPendingDeepLink(providerName){ try { localStorage.setItem(STORAGE_KEYS.PENDING_DEEPLINK, JSON.stringify({ provider: providerName, ts: Date.now() })); } catch(e){} }
  function clearPendingDeepLink(){ try{ localStorage.removeItem(STORAGE_KEYS.PENDING_DEEPLINK); }catch(e){} }
  function getPendingDeepLink(){ try{ const s = localStorage.getItem(STORAGE_KEYS.PENDING_DEEPLINK); return s ? JSON.parse(s) : null; }catch(e){return null;} }

  function openDeepLinkAndWait({ deepLink, installUrl, appName, providerName }){
    return new Promise((resolve) => {
      setPendingDeepLink(providerName || 'unknown');
      const tg = (window.Telegram && window.Telegram.WebApp) ? window.Telegram.WebApp : null;
      try {
        if (tg && typeof tg.openUrl === 'function'){ tg.openUrl(deepLink); } else { window.location.assign(deepLink); }
      } catch (e) { try { window.open(deepLink, '_self'); } catch(e2){ console.warn('open deep link failed', e2); } }

      showSheet({
        title: `Opening ${appName}`,
        bodyHtml: `<div class="small-muted">Opening ${escapeHtml(appName)} — return to this page after approving. Waiting for a response…</div><div style="margin-top:8px;" class="small-muted">If the app didn't open, choose "Try open" or install.</div>`,
        actionsHtml: `<button id="tryOpenNow" class="button">Try open ${escapeHtml(appName)}</button><button id="installApp" class="btn-ghost">Install ${escapeHtml(appName)}</button><button id="cancelWait" class="btn-ghost">Cancel</button>`,
        onMounted: ()=>{
          const tryOpen = $('tryOpenNow'); if (tryOpen) tryOpen.onclick = ()=>{ try{ window.location.assign(deepLink); }catch(e){ window.open(deepLink, '_blank'); } };
          const install = $('installApp'); if (install) install.onclick = ()=>{ try{ window.open(installUrl || deepLink, '_blank'); }catch(e){ try{ window.location.assign(installUrl || deepLink); }catch(_){} } };
          const cancel = $('cancelWait'); if (cancel) cancel.onclick = ()=>{ hideSheet(); clearPendingDeepLink(); resolve(false); };
        }
      });

      const start = Date.now();
      const interval = setInterval(async ()=>{
        const pk = parseReturnParams();
        if (pk && isValidSolanaPublicKey(pk)){
          clearInterval(interval);
          try { hideSheet(); } catch(e){}
          clearPendingDeepLink();
          const ok = await bindWalletWithPublicKey(pk, providerName);
          resolve(Boolean(ok));
          return;
        }
        if (Date.now() - start > 90000){
          clearInterval(interval);
          hideSheet();
          resolve(false);
          return;
        }
      }, 700);
    });
  }

  function phantomDeepLink(){ try { const origin = window.location.origin.replace(/\/+$/,''); return `https://phantom.app/ul/v1/authorize?app_url=${encodeURIComponent(origin)}&redirect_link=${encodeURIComponent(origin + window.location.pathname)}`; }catch(e){ return `https://phantom.app/`; } }
  function solflareDeepLink(){ try { const redirect = encodeURIComponent(window.location.origin.replace(/\/+$/,'') + window.location.pathname); return `https://solflare.com/access?redirect=${redirect}`; } catch(e){ return `https://solflare.com/`; } }
  function backpackDeepLink(){ return 'https://backpack.app/'; }

  async function connectWithPhantom(){ return await openDeepLinkAndWait({ deepLink: phantomDeepLink(), installUrl: 'https://phantom.app/', appName: 'Phantom', providerName: 'phantom' }); }
  async function connectWithSolflare(){ return await openDeepLinkAndWait({ deepLink: solflareDeepLink(), installUrl: 'https://solflare.com/', appName: 'Solflare', providerName: 'solflare' }); }
  async function connectWithBackpack(){ return await openDeepLinkAndWait({ deepLink: backpackDeepLink(), installUrl: 'https://backpack.app/', appName: 'Backpack', providerName: 'backpack' }); }

  async function connectWithWalletConnect(){ try { if (window.SOL_WALLETCONNECT_CONNECTOR && typeof window.SOL_WALLETCONNECT_CONNECTOR.connect === 'function'){ const pk = await window.SOL_WALLETCONNECT_CONNECTOR.connect({ redirect: buildCleanRedirect() }); if (pk) { const ok = await finalizeBind(pk, 'walletconnect'); return Boolean(ok); } } showSheet({ title:'WalletConnect', bodyHtml:`<div class="small-muted">No helper available. Open your mobile wallet and use WalletConnect; then paste the returned public key below.</div><div style="margin-top:8px;"><input id="wcManual" style="width:100%; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.06)" placeholder="Paste public key" /></div>`, actionsHtml:`<button id="wcBind" class="button">Bind</button><button id="wcClose" class="btn-ghost">Close</button>`, onMounted: ()=> { const b = $('wcBind'); const c = $('wcClose'); if (b){ b.onclick = async ()=> { const pk = ($('wcManual').value||'').trim(); if (!pk) return alert('Paste public key'); hideSheet(); const ok = await finalizeBind(pk, 'walletconnect'); if (!ok) showToast('Bind failed',1200); }; } if (c) c.onclick = hideSheet; } }); return false; } catch(e){ console.warn('connectWithWalletConnect failed', e); return false; } }

  window.connectWithPhantom = connectWithPhantom;
  window.connectWithSolflare = connectWithSolflare;
  window.connectWithBackpack = connectWithBackpack;
  window.connectWithWalletConnect = connectWithWalletConnect;
  window.openPhantomDeepLink = () => openDeepLinkAndWait({ deepLink: phantomDeepLink(), installUrl: 'https://phantom.app/', appName: 'Phantom', providerName: 'phantom' });
  window.openSolflareDeepLink = () => openDeepLinkAndWait({ deepLink: solflareDeepLink(), installUrl: 'https://solflare.com/', appName: 'Solflare', providerName: 'solflare' });
  window.openBackpackDeepLink = () => openDeepLinkAndWait({ deepLink: backpackDeepLink(), installUrl: 'https://backpack.app/', appName: 'Backpack', providerName: 'backpack' });
  window.showWalletPicker = function(){ showSheet({ title:'Connect Wallet', bodyHtml: $('sheetBody').innerHTML }); };

  function extractPublicKeyFromProviderResponse(resp){
    try {
      if (!resp) return null;
      if (typeof resp === 'string') return resp;
      if (resp.publicKey && typeof resp.publicKey.toString === 'function') return resp.publicKey.toString();
      if (resp.publicKey && typeof resp.publicKey === 'string') return resp.publicKey;
      if (resp.public_key && typeof resp.public_key === 'string') return resp.public_key;
      if (resp.address && typeof resp.address === 'string') return resp.address;
      if (resp.data && resp.data.publicKey) return resp.data.publicKey;
      const s = JSON.stringify(resp);
      const match = s.match(/([1-9A-HJ-NP-Za-km-z]{32,64})/);
      if (match) return match[1];
    } catch(e){}
    return null;
  }

  async function bindWalletWithPublicKey(publicKey, providerName){
    try {
      const payload = { sessionId: clientState.sessionId, wallet: publicKey, walletProvider: providerName||null, referral: clientState.pendingReferral || clientState.referralCode || null, username: clientState.username, telegramId: clientState.telegramId };
      const res = await api('/wallet/bind','POST', payload);
      if (res && res.ok){
        if (res.sessionId && res.sessionId !== clientState.sessionId){ clientState.sessionId = res.sessionId; saveSessionToStorage(clientState.sessionId); }
        clientState.wallet = publicKey;
        clientState.userId = res.userId ?? clientState.userId;
        clientState.gpBase = typeof res.gp !== 'undefined' ? Number(res.gp) : clientState.gpBase;
        clientState.miners = res.miners ?? clientState.miners;
        clientState.userAU = res.userAU ?? clientState.userAU;
        clientState.totalAU = res.totalAU ?? clientState.totalAU;
        clientState.referralCode = res.referralCode ?? clientState.referralCode;
        clientState.referralsActive = res.referralsActive ?? clientState.referralsActive;
        if (res.referralAccepted) clearPendingReferral();
        if (typeof res.score !== 'undefined'){
          clientState.serverScore = Number(res.score);
          clientState.lastSent = clientState.lastSent || {};
          clientState.lastSent.score = Number(res.score);
        }
        clientState.lastSent = clientState.lastSent || {};
        clientState.lastSent.gpTotal = Number(clientState.gpBase || 0);

        if (typeof res.energy === 'number') {
          setEnergy(Math.max(0, Math.min(100, res.energy)), true);
        }

        saveBoundWalletToStorage(publicKey, providerName || clientState.walletProvider || null);
        saveClientToStorage();
        updateUI(); renderMinersList();
        return true;
      }
      return false;
    } catch(e){ console.warn('bindWalletWithPublicKey error', e); return false; }
  }

  window.finalizeBind = async function(publicKey, providerName){
    if (!publicKey) { showSheet({ title:'Wallet', bodyHtml:'<div class="small-muted">No public key provided</div>' }); setTimeout(hideSheet, 900); return false; }
    if (!isValidSolanaPublicKey(publicKey)) { showSheet({ title:'Wallet', bodyHtml:'<div class="small-muted">Public key format invalid</div>' }); setTimeout(hideSheet,1200); return false; }
    clientState.walletProvider = providerName || clientState.walletProvider || null;
    const ok = await bindWalletWithPublicKey(publicKey, providerName);
    if (ok){
      clientState.wallet = publicKey;
      clientState.walletProvider = providerName;
      saveBoundWalletToStorage(publicKey, providerName);
      updateUI();
      hideSheet();
      showToast(`Wallet connected (${providerName || 'manual'})`, 1000);
      return true;
    } else {
      showSheet({ title:'Wallet', bodyHtml:`<div class="small-muted">Server bind failed for ${escapeHtml(providerName || 'wallet')}</div>`, actionsHtml:`<button id="retryBind" class="button">Try again</button><button id="closeBind" class="btn-ghost">Close</button>`, onMounted: ()=> { const r=$('retryBind'); if (r) r.onclick = ()=> { hideSheet(); showSheet({ title:'Connect Wallet' }); }; const c=$('closeBind'); if (c) c.onclick = hideSheet; }});
      return false;
    }
  };

  function parseReturnParams(){
    try {
      let combined = window.location.search || '';
      if (window.location.hash){
        const h = window.location.hash.replace(/^#/,'');
        if (h.indexOf('?') !== -1) combined += (combined ? '&' : '') + h.split('?').slice(1).join('?');
        else combined += (combined ? '&' : '') + h;
      }
      const params = new URLSearchParams(combined);
      const names = ['phantom_public_key','phantom_encryption_public_key','public_key','publicKey','public-key','wallet','pk','address','account','account_id','publicKeyBase58'];
      for (const n of names){ const v = params.get(n); if (v) return v; }
      const raw = params.get('result') || params.get('response') || params.get('data');
      if (raw){
        try {
          const parsed = JSON.parse(raw);
          if (parsed && (parsed.publicKey || parsed.address || parsed.pk)) return parsed.publicKey || parsed.address || parsed.pk;
          for (const k of Object.keys(parsed || {})){
            const val = parsed[k];
            if (typeof val === 'string' && isValidSolanaPublicKey(val)) return val;
          }
        } catch(e){}
      }
      const full = window.location.href;
      const match = full.match(/([1-9A-HJ-NP-Za-km-z]{32,64})/);
      if (match) return match[1];
      return null;
    } catch(e){ return null; }
  }

  function readWalletReturn(){
    try {
      const pk = parseReturnParams();
      if (pk){
        (async ()=> {
          if (!isValidSolanaPublicKey(pk)){ showSheet({ title:'Wallet', bodyHtml:'<div class="small-muted">Returned public key appears invalid</div>' }); setTimeout(hideSheet,1200); return; }
          const pending = getPendingDeepLink();
          const provider = pending && pending.provider ? pending.provider : null;
          const ok = await bindWalletWithPublicKey(pk, provider);
          try { const cleanUrl = window.location.origin + window.location.pathname; history.replaceState({}, document.title, cleanUrl); } catch(e){}
          clearPendingDeepLink();
          if (ok) { clearPendingReferral(); showToast('Wallet connected',1000); } else { showSheet({ title:'Wallet', bodyHtml:'<div class="small-muted">Wallet connect failed — open app and try again</div>' }); setTimeout(hideSheet,1200); }
        })();
        return true;
      }
      return false;
    } catch(e){ console.warn('readWalletReturn error', e); return false; }
  }

  function setupInjectedProviderListeners(){
    try {
      if (window.solana && typeof window.solana.on === 'function'){
        try {
          window.solana.on('connect', async (pk) => {
            try {
              const publicKey = (pk && pk.toString) ? pk.toString() : (pk && pk.publicKey && pk.publicKey.toString ? pk.publicKey.toString() : pk);
              if (publicKey && (!clientState.wallet || clientState.wallet !== publicKey)){
                const det = detectInjectedProviders();
                clientState.walletProvider = det.phantom ? 'phantom' : (det.solflare ? 'solflare' : (det.backpack ? 'backpack' : clientState.walletProvider));
                const ok = await bindWalletWithPublicKey(publicKey, clientState.walletProvider);
                if (ok) showToast('Wallet connected',900);
              }
            } catch(e){ console.warn('provider connect handler error', e); }
          });
          window.solana.on('disconnect', () => { clientState.wallet = null; clientState.walletProvider = null; clearBoundWalletFromStorage(); updateUI(); saveClientToStorage(); });
        } catch(e){ console.warn('solana listener setup failed', e); }
      }
      if (window.solflare && typeof window.solflare.on === 'function'){
        try {
          window.solflare.on('connect', async (pk) => {
            const publicKey = (pk && pk.toString) ? pk.toString() : (pk && pk.publicKey && pk.publicKey.toString ? pk.publicKey.toString() : pk);
            if (publicKey && (!clientState.wallet || clientState.wallet !== publicKey)){
              clientState.walletProvider = 'solflare';
              const ok = await bindWalletWithPublicKey(publicKey, 'solflare');
              if (ok) showToast('Wallet connected',900);
            }
          });
          window.solflare.on('disconnect', ()=> { clientState.wallet = null; clientState.walletProvider = null; clearBoundWalletFromStorage(); updateUI(); saveClientToStorage(); });
        } catch(e){}
      }
      if (window.backpack && typeof window.backpack.on === 'function'){
        try {
          window.backpack.on('connect', async (pk) => {
            const publicKey = (pk && pk.toString) ? pk.toString() : (pk && pk.publicKey && pk.publicKey.toString ? pk.publicKey.toString() : pk);
            if (publicKey && (!clientState.wallet || clientState.wallet !== publicKey)){
              clientState.walletProvider = 'backpack';
              const ok = await bindWalletWithPublicKey(publicKey, 'backpack');
              if (ok) showToast('Wallet connected',900);
            }
          });
          window.backpack.on('disconnect', ()=> { clientState.wallet = null; clientState.walletProvider = null; clearBoundWalletFromStorage(); updateUI(); saveClientToStorage(); });
        } catch(e){}
      }
    } catch(e){ console.warn('setupInjectedProviderListeners failed', e); }
  }

  async function getMyReferral(){
    try {
      const resp = await api('/player/referral','GET');
      if (resp && resp.refCode){ clientState.referralCode = resp.refCode; clientState.referralsActive = resp.count ?? clientState.referralsActive; saveClientToStorage(); }
      return clientState.referralCode;
    } catch(e){ console.warn('getMyReferral', e); return clientState.referralCode; }
  }

  // -----------------------
  // Referral modal
  // -----------------------
  function showReferralModal(){
    (async ()=>{
      let code = clientState.referralCode || await getMyReferral();
      if (!code) code = 'UNKNOWN';
      const webTme = `https://t.me/${encodeURIComponent(TELEGRAM_BOT_USERNAME)}?start=${encodeURIComponent(code)}`;
      const body = `<div style="text-align:left">
        <div class="small-muted">Share your referral — both of you can earn rewards</div>
        <div style="margin-top:8px;">
          <label class="small-muted">Telegram web link</label>
          <input id="refLinkWeb" style="width:100%; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.06)" value="${escapeHtml(webTme)}" readonly>
        </div>
      </div>`;
      const actions = `<button id="copyRefBtn" class="button"><i class="fa-solid fa-copy"></i> Copy Link</button><button id="shareRefBtn" class="btn-ghost"><i class="fa-solid fa-share-from-square"></i> Share</button><button id="openWeb" class="button"><i class="fa-solid fa-arrow-up-right-from-square"></i> Open in Telegram Web</button><button id="closeRef" class="btn-ghost">Close</button>`;
      showSheet({ title:'Invite Friends', bodyHtml: body + `<div style="margin-top:8px;" class="small-muted">Referrals: ${clientState.referralsActive || 0}</div>`, actionsHtml: actions, onMounted: ()=> {
        const copy = $('copyRefBtn'); const share = $('shareRefBtn'); const close = $('closeRef'); const box = $('refLinkWeb'); const openBtn = $('openWeb');
        if (copy) copy.onclick = async ()=> { try { await navigator.clipboard.writeText(box.value); showToast('Copied!',900); hideSheet(); } catch(e){ alert('Copy failed — please long-press the link and copy manually.'); } };
        if (share) share.onclick = async ()=> { try { const textToShare = `Join me on Hexon! ${box.value}`; if (navigator.share) { await navigator.share({ title:'Play Hexon', text:'Join me on Hexon', url: box.value }); hideSheet(); } else { const shareUrl = `https://t.me/share/url?url=${encodeURIComponent(box.value)}&text=${encodeURIComponent('Join me on Hexon!')}`; try { window.open(shareUrl, '_blank'); } catch(e){ location.href = shareUrl; } } } catch(e){} };
        if (openBtn) openBtn.onclick = ()=> { try { const tg = (window.Telegram && window.Telegram.WebApp) ? window.Telegram.WebApp : null; if (tg && typeof tg.openUrl === 'function') { tg.openUrl(box.value); } else { window.open(box.value, '_blank'); } } catch(e){ try { window.open(box.value, '_blank'); }catch(_){} } };
        if (close) close.onclick = hideSheet;
      }});
    })();
  }

  // -----------------------
  // Claim / rewards flow adjustments (we now show HXN server balance & sync)
  // -----------------------
  async function claimRewards(){
    // keep existing GP claim flow (rewards_claim) for GP, but show HXN info in sheet
    showSheet({ title:'Claim', bodyHtml:'<div class="small-muted">Requesting claim…</div>' });
    try {
      // refresh HXN balance first
      await fetchHxnBalance();

      const balance = clientState.hxnBalance != null ? prettyHxn(clientState.hxnBalance) : '—';
      const credits = clientState.hxnCredits != null ? prettyHxn(clientState.hxnCredits) : '—';
      const body = `<div style="text-align:left">
        <div class="small-muted">HXN balance (server): <b>${escapeHtml(balance)} HXN</b></div>
        <div class="small-muted" style="margin-top:6px">Ledger credits: ${escapeHtml(credits)} HXN</div>
        <div class="small-muted" style="margin-top:8px">AU: ${clientState.userAU || 0} • total AU: ${clientState.totalAU || 0}</div>
        <div style="margin-top:10px;" class="small-muted">To withdraw on-chain, implement a withdrawal endpoint or follow the off-chain payout procedure in your backend.</div>
      </div>`;
      const actions = `<button id="refreshHxn" class="button"><i class="fa-solid fa-sync"></i> Refresh</button><button id="closeClaim" class="btn-ghost">Close</button>`;
      showSheet({ title:'Claim HXN', bodyHtml: body, actionsHtml: actions, onMounted: ()=> {
        const r = $('refreshHxn'); const c = $('closeClaim');
        if (r) r.onclick = async ()=> { r.disabled=true; await syncHxnMining(); await fetchHxnBalance(); r.disabled=false; hideSheet(); showToast('Synced and refreshed',1200); };
        if (c) c.onclick = hideSheet;
      }});
    } catch(e){ console.warn('claimRewards error', e); showSheet({ title:'Claim', bodyHtml:'<div class="small-muted">Network error — try again later.</div>' }); setTimeout(hideSheet,1200); }
  }

  function isValidSolanaPublicKey(pk){
    if (!pk || typeof pk !== 'string') return false;
    const base58Regex = /^[1-9A-HJ-NP-Za-km-z]+$/;
    if (!base58Regex.test(pk)) return false;
    if (pk.length < 32 || pk.length > 64) return false;
    return true;
  }

  // -----------------------
  // Bottom sheet wiring (unchanged behavior)
  // -----------------------
  (function sheetBootstrap(){
    function tgInstance(){ try{ return (window.Telegram && window.Telegram.WebApp) ? window.Telegram.WebApp : null; }catch(e){return null;} }
    function openExternal(url){
      const tg = tgInstance();
      if (tg){
        try { if (typeof tg.openUrl === 'function'){ tg.openUrl(url); return; } if (typeof tg.openLink === 'function'){ tg.openLink(url); return; } if (typeof tg.openPopup === 'function'){ tg.openPopup(url); return; } } catch(e){ console.warn('tg.open* failed', e); }
      }
      try { window.location.assign(url); } catch(e){ try { window.open(url, '_blank'); } catch(e2){ console.warn('openExternal fallback failed', e2); } }
    }

    const overlay = document.getElementById('overlay');
    const sheetClose = document.getElementById('sheetClose');
    const sheetCancel = document.getElementById('sheetCancel');
    const bindBtn = document.getElementById('bindWalletBtn');
    const sheetBody = document.getElementById('sheetBody');

    function showSheetLocal(opts = {}) {
      if (!overlay) return;
      if (opts.title !== undefined) document.querySelector('.sheet-title').textContent = opts.title;
      if (opts.bodyHtml !== undefined) sheetBody.innerHTML = opts.bodyHtml;
      if (opts.actionsHtml !== undefined) document.getElementById('sheetActions').innerHTML = opts.actionsHtml;
      overlay.classList.add('show'); overlay.setAttribute('aria-hidden','false');
      try{ const tg = tgInstance(); if (tg && typeof tg.expand === 'function') tg.expand(); }catch(e){}
      try{ sheetBody.focus(); }catch(e){}
      if (typeof opts.onMounted === 'function') { setTimeout(()=> { try{ opts.onMounted(); }catch(e){ console.warn('sheet onMounted failed', e); } }, 50); }
      setDetectionBadges();
    }
    function hideSheetLocal(){ if (!overlay) return; overlay.classList.remove('show'); overlay.setAttribute('aria-hidden','true'); }

    function setDetectionBadges(){
      const d = detectInjectedProviders();
      try {
        document.getElementById('det-phantom').textContent = d.phantom ? '• detected' : '';
        document.getElementById('det-solflare').textContent = d.solflare ? '• detected' : '';
        document.getElementById('det-backpack').textContent = d.backpack ? '• detected' : '';
      } catch(e){}
    }

    const optionMap = {
      'opt-phantom': async ()=> {
        try {
          const ok = await connectWithPhantom();
          if (ok) { hideSheetLocal(); return; }
          openExternal(phantomDeepLink());
        } catch(e){ console.warn(e); showToast('Connection failed', 1200); }
      },
      'opt-solflare': async ()=> {
        try {
          const ok = await connectWithSolflare();
          if (ok) { hideSheetLocal(); return; }
          openExternal(solflareDeepLink());
        } catch(e){ console.warn(e); showToast('Connection failed', 1200); }
      },
      'opt-backpack': async ()=> {
        try {
          const ok = await connectWithBackpack();
          if (ok) { hideSheetLocal(); return; }
          openExternal(backpackDeepLink());
        } catch(e){ console.warn(e); showToast('Connection failed', 1200); }
      },
      'opt-wc': async ()=> {
        try {
          const ok = await connectWithWalletConnect();
          if (ok){ hideSheetLocal(); return; }
          const tg = tgInstance();
          if (tg) { alert('Open your mobile wallet and choose WalletConnect. Then paste the returned public key into Hexon.'); } else { alert('Open your wallet app and choose WalletConnect, or use a WalletConnect-enabled wallet.'); }
        } catch(e){ console.warn(e); alert('WalletConnect attempt failed'); }
      }
    };

    async function manualBind(publicKey){
      if (!publicKey || publicKey.length < 20){ alert('Invalid public key'); return; }
      if (typeof window.finalizeBind === 'function'){
        try { const ok = await window.finalizeBind(publicKey, 'manual'); if (ok) hideSheetLocal(); return; } catch(e){ console.warn('finalizeBind failed', e); alert('Server bind failed'); return; }
      }
      try { localStorage.setItem(STORAGE_KEYS.BOUND_WALLET, publicKey); localStorage.setItem(STORAGE_KEYS.BOUND_PROVIDER, 'manual'); const wEl = document.getElementById('ui-wallet'); const pEl = document.getElementById('ui-provider'); if (wEl) wEl.textContent = publicKey; if (pEl) pEl.textContent = 'manual'; hideSheetLocal(); showToast('Public key stored locally (no server bind performed).', 2000); } catch(e){ console.warn(e); alert('Unable to save locally'); }
    }

    function interceptBind(ev){ ev.preventDefault(); ev.stopImmediatePropagation(); showSheetLocal({ title:'Connect Wallet', bodyHtml: sheetBody.innerHTML }); return false; }

    function onKeyDown(e){ if (e.key === 'Escape' && overlay.classList.contains('show')){ hideSheetLocal(); } }

    document.addEventListener('DOMContentLoaded', ()=>{
      if (bindBtn){ bindBtn.addEventListener('pointerdown', interceptBind, { capture:true, passive:false }); bindBtn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); showSheetLocal({ title:'Connect Wallet', bodyHtml: sheetBody.innerHTML }); }, { passive:false }); bindBtn.addEventListener('keydown', (e)=>{ if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); showSheetLocal({ title:'Connect Wallet', bodyHtml: sheetBody.innerHTML }); } }); }

      if (sheetClose) sheetClose.addEventListener('click', hideSheetLocal);
      if (sheetCancel) sheetCancel.addEventListener('click', hideSheetLocal);
      overlay.addEventListener('pointerdown', (ev)=>{ if (ev.target === overlay) hideSheetLocal(); });

      Object.keys(optionMap).forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        el.addEventListener('pointerdown', async (ev)=>{ ev.preventDefault(); ev.stopImmediatePropagation(); try{ await optionMap[id](); } catch(e){ console.warn(e); showToast('Connection failed', 1200); } }, { passive:false });
        el.addEventListener('keydown', (e)=>{ if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); optionMap[id](); } });
      });

      const manualBtn = document.getElementById('manualBindBtn');
      if (manualBtn){ manualBtn.addEventListener('pointerdown', async (ev)=>{ ev.preventDefault(); ev.stopPropagation(); const pk = (document.getElementById('manualPublicKey').value||'').trim(); await manualBind(pk); }, { passive:false }); }

      setDetectionBadges();
      try{ const sid = localStorage.getItem(STORAGE_KEYS.SESSION); if (sid && document.getElementById('ui-session')) document.getElementById('ui-session').textContent = sid; const wallet = localStorage.getItem(STORAGE_KEYS.BOUND_WALLET); if (wallet && document.getElementById('ui-wallet')) document.getElementById('ui-wallet').textContent = wallet; const prov = localStorage.getItem(STORAGE_KEYS.BOUND_PROVIDER); if (prov && document.getElementById('ui-provider')) document.getElementById('ui-provider').textContent = prov; } catch(e){}
      document.addEventListener('keydown', onKeyDown);
    });

    window._hexon_openWalletSheet = ()=> showSheetLocal({ title:'Connect Wallet', bodyHtml: sheetBody.innerHTML });
    window._hexon_closeWalletSheet = hideSheetLocal;
    window._hexon_showSheet = showSheetLocal;
    window._hexon_hideSheet = hideSheetLocal;
    window._hexon_showToast = (m,t)=> { const tEl = document.getElementById('toast'); if (!tEl) return; tEl.textContent = m; tEl.style.display = 'block'; setTimeout(()=> tEl.style.display='none', t || 2000); };
  })();

  // -----------------------
  // Pause / resume (page visibility) helpers (HARDENED)
  // -----------------------
  function pauseForHidden(){
    try {
      const scene = phaserGame && phaserGame.scene && phaserGame.scene.keys && phaserGame.scene.keys.GameScene;
      gameState.wasPlayingBeforeHidden = gameState.isPlaying;

      if (!gameState.isPlaying) {
        gameState.hiddenAt = Date.now();
        saveGameToStorage();
        return;
      }

      try {
        const now = Date.now();
        const di = Math.max(40, gameState.dropInterval || INITIAL_DROP_MS);
        if (gameState.lastTickAt && Number.isFinite(gameState.lastTickAt)){
          const elapsed = Math.max(0, now - gameState.lastTickAt);
          gameState.tickRemaining = ((di - (elapsed % di)) + di) % di || di;
        } else {
          gameState.tickRemaining = di;
        }
      } catch(e){
        gameState.tickRemaining = gameState.dropInterval || INITIAL_DROP_MS;
      }

      gameState.isPlaying = false;
      gameState.hiddenAt = Date.now();
      if (scene){
        try { if (typeof scene.pauseDropLoop === 'function') scene.pauseDropLoop(); else if (scene.dropEvent && typeof scene.dropEvent.paused !== 'undefined') scene.dropEvent.paused = true; } catch(e){}
      }
      sendState('pause');
      saveGameToStorage();
      saveClientToStorage();
    } catch(e){ console.warn('pauseForHidden error', e); }
  }

  function resumeFromHidden(){
    try {
      applyOfflineEnergyRecharge();

      const scene = phaserGame && phaserGame.scene && phaserGame.scene.keys && phaserGame.scene.keys.GameScene;
      const was = gameState.wasPlayingBeforeHidden;
      const forced = gameState._forceResume === true;

      if (was === true || forced) {
        gameState.isPlaying = true;

        if (scene) {
          try {
            if (gameState.tickRemaining && Number.isFinite(gameState.tickRemaining) && gameState.tickRemaining > 0){
              if (typeof scene.resumeDropLoop === 'function') scene.resumeDropLoop(gameState.tickRemaining);
              else scene.startDropLoop(gameState.tickRemaining);
            } else {
              if (scene.dropEvent && typeof scene.dropEvent.paused !== 'undefined'){
                scene.dropEvent.paused = false;
              } else if (typeof scene.startDropLoop === 'function'){
                scene.startDropLoop();
              }
            }
          } catch(e){
            try { if (typeof scene.startDropLoop === 'function') scene.startDropLoop(); } catch(_) {}
          }
        }

        gameState.lastTickAt = Date.now();
        sendState('resume');
        saveGameToStorage();
        saveClientToStorage();
        updateUI();
      } else {
        gameState.lastTickAt = Date.now();
        saveGameToStorage();
      }

      delete gameState.hiddenAt;
      delete gameState.wasPlayingBeforeHidden;
      delete gameState._forceResume;
    } catch(e){ console.warn('resumeFromHidden error', e); }
  }

  // -----------------------
  // Helper: resume after energy refill
  // -----------------------
  function attemptResumeAfterEnergy(){
    try {
      applyOfflineEnergyRecharge();

      if (gameState.pausedForEnergy && (clientState.energy || 0) > 0){
        gameState.pausedForEnergy = false;
        if (!gameState.activePiece) spawnPiece();
        gameState.isPlaying = true;

        if (!gameState.tickRemaining){
          try {
            if (gameState.lastTickAt && Number.isFinite(gameState.dropInterval)){
              const di = Math.max(40, gameState.dropInterval || INITIAL_DROP_MS);
              const elapsed = Math.max(0, Date.now() - gameState.lastTickAt);
              gameState.tickRemaining = ((di - (elapsed % di)) + di) % di || di;
            } else {
              gameState.tickRemaining = gameState.dropInterval || INITIAL_DROP_MS;
            }
          } catch(e){
            gameState.tickRemaining = gameState.dropInterval || INITIAL_DROP_MS;
          }
        }

        try {
          const sceneRef = phaserGame && phaserGame.scene && phaserGame.scene.keys && phaserGame.scene.keys.GameScene;
          if (sceneRef){
            if (gameState.tickRemaining && Number.isFinite(gameState.tickRemaining) && gameState.tickRemaining > 0){
              sceneRef.resumeDropLoop(gameState.tickRemaining);
            } else if (sceneRef.dropEvent && typeof sceneRef.dropEvent.paused !== 'undefined'){
              sceneRef.dropEvent.paused = false;
            } else if (typeof sceneRef.startDropLoop === 'function'){
              sceneRef.startDropLoop();
            }
          }
        } catch(e){ console.warn('attemptResumeAfterEnergy startDropLoop failed', e); }
        saveGameToStorage();
        saveClientToStorage();
        updateUI();
        showToast('Energy credited — resuming game', 1200);
        sendState('resume_energy');
      }
    } catch(e){ console.warn('attemptResumeAfterEnergy error', e); }
  }

  // -----------------------
  // Boot / init & Phaser startup (main)
  // -----------------------
  document.addEventListener('DOMContentLoaded', async ()=>{
    try {
      initTelegram();
      readWalletReturn();

      const ref = getRefFromURL();
      if (ref) savePendingReferral(ref); else loadPendingReferral();

      try{ const wa = $('watchAdBtn'); if (wa) wa.addEventListener('click', showAdAndVerify); } catch(e){}
      try{ const os = $('openStore'); if (os) os.addEventListener('click', ()=> window.location.href = 'shop.html'); } catch(e){}
      try{ const bw = $('bindWalletBtn'); if (bw) bw.addEventListener('click', (ev)=> { ev.preventDefault(); ev.stopPropagation(); if (typeof window._hexon_openWalletSheet === 'function') { window._hexon_openWalletSheet(); } else { showSheet({ title: 'Connect Wallet' }); } }); } catch(e){}
      try{ const sr = $('showRefBtn'); if (sr) sr.addEventListener('click', showReferralModal); } catch(e){}
      try{ const va = $('viewAlloc'); if (va) va.addEventListener('click', ()=> showSheet({ title: 'Allocation', bodyHtml: '<div class="small-muted">Allocation preview</div>' })); } catch(e){}
      try{ const cr = $('claimRewardBtn'); if (cr) cr.addEventListener('click', claimRewards); } catch(e){}
      try{ const sh = $('syncHxnBtn'); if (sh) sh.addEventListener('click', async ()=> { sh.disabled=true; await syncHxnMining(); sh.disabled=false; }); } catch(e){}

      try{ const rb = $('resetGameBtn'); if (rb) rb.addEventListener('click', ()=> { resetForPlay(); showToast('Game reset',900); }); } catch(e){}

      // Load saved client and game state from localStorage
      const savedClient = loadClientFromStorage();
      if (savedClient){
        const keepSession = clientState.sessionId;
        Object.assign(clientState, savedClient);
        clientState.sessionId = keepSession || clientState.sessionId;
      }

      clientState.lastSent = clientState.lastSent || { gpTotal: Number(clientState.gpBase || 0), score: Number(clientState.serverScore || 0) };

      normalizeAdStateOnLoad();
      setInterval(resetDailyAdsIfNeeded, 60e3);

      applyOfflineEnergyRecharge();

      const savedGame = loadGameFromStorage();
      let shouldAttemptResume = false;
      let resumeTickRemaining = null;

      if (savedGame){
        try {
          if (Array.isArray(savedGame.grid) && savedGame.grid.length === GRID_ROWS){
            gameState.grid = savedGame.grid;
            gameState.activePiece = savedGame.activePiece;
            gameState.nextPiece = savedGame.nextPiece;
            gameState.score = savedGame.score || 0;
            gameState.level = savedGame.level || 1;
            gameState.lines = savedGame.lines || 0;
            gameState.dropInterval = savedGame.dropInterval || INITIAL_DROP_MS;
            gameState.isPlaying = savedGame.isPlaying !== undefined ? savedGame.isPlaying : true;
            gameState.combo = savedGame.combo || 0;
            gameState.lastSavedAt = savedGame.lastSavedAt || Date.now();
            gameState.lastTickAt = savedGame.lastTickAt || Date.now();
            gameState.hiddenAt = savedGame.hiddenAt || null;
            gameState.wasPlayingBeforeHidden = savedGame.wasPlayingBeforeHidden || null;
            gameState.pausedForEnergy = savedGame.pausedForEnergy || false;
            gameState.tickRemaining = savedGame.tickRemaining || null;

            const wasPlayingFlag = Boolean(savedGame.wasPlayingBeforeHidden);
            const savedMarkedPlaying = Boolean(savedGame.isPlaying);
            const hadHidden = Boolean(savedGame.hiddenAt);

            if (wasPlayingFlag || savedMarkedPlaying || hadHidden) {
              shouldAttemptResume = true;
              if (savedGame.tickRemaining && Number.isFinite(savedGame.tickRemaining)) {
                resumeTickRemaining = savedGame.tickRemaining;
              } else if (savedGame.lastTickAt && savedGame.dropInterval) {
                const di = Math.max(40, savedGame.dropInterval || INITIAL_DROP_MS);
                const elapsed = Math.max(0, Date.now() - savedGame.lastTickAt);
                resumeTickRemaining = ((di - (elapsed % di)) + di) % di || di;
              } else {
                resumeTickRemaining = savedGame.dropInterval || INITIAL_DROP_MS;
              }
            }

            if (gameState.hiddenAt) gameState.isPlaying = false;

            if (gameState.pausedForEnergy && (clientState.energy || 0) > 0){
              gameState.pausedForEnergy = false;
              if (!gameState.activePiece) spawnPiece();
              gameState.isPlaying = true;
            }
          } else {
            initGrid();
            clearSavedGame();
          }
        } catch(e){
          initGrid();
          clearSavedGame();
        }
      } else {
        if (!gameState.grid) initGrid();
        if (!gameState.activePiece) spawnPiece();
      }

      // Server init
      try {
        const init = await api('/client/init','POST',{ sessionId: clientState.sessionId, referral: clientState.pendingReferral || null, username: clientState.username, telegramId: clientState.telegramId });
        if (init){
          if (init.sessionId && init.sessionId !== clientState.sessionId){ clientState.sessionId = init.sessionId; saveSessionToStorage(clientState.sessionId); }
          clientState.userId = init.userId ?? clientState.userId;
          clientState.gpBase = init.gp ?? clientState.gpBase;
          clientState.miners = init.miners ?? clientState.miners;
          clientState.userAU = init.userAU ?? clientState.userAU;
          clientState.totalAU = init.totalAU ?? clientState.totalAU;
          clientState.referralsActive = init.referralsActive ?? clientState.referralsActive;
          clientState.referralCode = init.referralCode ?? clientState.referralCode;
          if (!clientState.username && init.username) clientState.username = init.username;
          if (init.referralAccepted) clearPendingReferral();
          if (init.wallet) { clientState.wallet = init.wallet; clientState.walletProvider = init.walletProvider || clientState.walletProvider; saveBoundWalletToStorage(clientState.wallet, clientState.walletProvider); }
          if (typeof init.energy === 'number') setEnergy(Math.max(0, Math.min(100, init.energy)), true);

          if (typeof init.score !== 'undefined'){
            clientState.serverScore = Number(init.score);
            clientState.lastSent = clientState.lastSent || {};
            clientState.lastSent.score = Number(init.score);
          }

          clientState.lastSent = clientState.lastSent || {};
          clientState.lastSent.gpTotal = Number(clientState.gpBase || 0);

          saveClientToStorage();
        }
      } catch(e){ console.warn('client init failed', e); }

      // Size the Phaser canvas to available area
      const parentEl = $('phaserCanvas') || document.body;
      const rect = parentEl.getBoundingClientRect();
      const availW = Math.max(320, rect.width || Math.min(window.innerWidth * 0.98, 900));
      const availH = Math.max(260, Math.min(window.innerHeight * 0.68, rect.height || window.innerHeight * 0.68));
      const desiredGrid = gridPixelSize(GRID_COLS, GRID_ROWS);
      const desiredW = desiredGrid.width + BOARD_PADDING * 2;
      const desiredH = desiredGrid.height + BOARD_PADDING * 2;
      const scale = Math.min(1, Math.min(availW / desiredW, availH / desiredH));
      CELL = Math.max(8, Math.floor(BASE_CELL * scale));
      GAP = Math.max(1, Math.floor(BASE_GAP * scale));
      const canvasWidth = GRID_COLS * CELL + Math.max(0, GRID_COLS - 1) * GAP + BOARD_PADDING * 2;
      const canvasHeight = GRID_ROWS * CELL + Math.max(0, GRID_ROWS - 1) * GAP + BOARD_PADDING * 2;

      if (parentEl && parentEl.style){
        parentEl.style.width = '100%';
        parentEl.style.maxWidth = canvasWidth + 'px';
        parentEl.style.height = canvasHeight + 'px';
        parentEl.style.display = 'flex';
        parentEl.style.alignItems = 'center';
        parentEl.style.justifyContent = 'center';
        parentEl.style.margin = '0 auto';
      }

      phaserGame = new Phaser.Game({
        type: Phaser.AUTO,
        parent: 'phaserCanvas',
        backgroundColor: '#061426',
        scene: [ BootScene, GameScene ],
        render: { pixelArt: false, antialias: true },
        scale: {
          mode: Phaser.Scale.FIT,
          autoCenter: Phaser.Scale.CENTER_BOTH,
          width: canvasWidth,
          height: canvasHeight
        }
      });

      // resume saved game if needed
      if (shouldAttemptResume) {
        setTimeout(()=> {
          if ((clientState.energy || 0) > 0) {
            gameState._forceResume = true;
            gameState.tickRemaining = resumeTickRemaining || gameState.tickRemaining || gameState.dropInterval || INITIAL_DROP_MS;
            resumeFromHidden();
            showToast('Resuming previous game…', 1200);
          } else {
            gameState.pausedForEnergy = true;
            saveGameToStorage();
            updateUI();
          }
        }, 300);
      }

      function onResize(){
        try {
          const parentRect = (document.getElementById('phaserCanvas') || document.body).getBoundingClientRect();
          const availW = Math.max(320, parentRect.width || window.innerWidth);
          const availH = Math.max(260, Math.min(window.innerHeight * 0.78, parentRect.height || window.innerHeight * 0.78));
          const desiredGrid = gridPixelSize(GRID_COLS, GRID_ROWS);
          const desiredW_local = desiredGrid.width + BOARD_PADDING * 2;
          const desiredH_local = desiredGrid.height + BOARD_PADDING * 2;
          const scale = Math.min(1, Math.min(availW / desiredW_local, availH / desiredH_local));
          CELL = Math.max(8, Math.floor(BASE_CELL * scale));
          GAP = Math.max(1, Math.floor(BASE_GAP * scale));
          const w = GRID_COLS * CELL + Math.max(0, GRID_COLS - 1) * GAP + BOARD_PADDING * 2;
          const h = GRID_ROWS * CELL + Math.max(0, GRID_ROWS - 1) * GAP + BOARD_PADDING * 2;
          const sc = phaserGame && phaserGame.scale;
          if (sc && typeof sc.resize === 'function') sc.resize(w, h);
          if (document.getElementById('phaserCanvas')) {
            const p = document.getElementById('phaserCanvas');
            p.style.height = h + 'px';
            p.style.maxWidth = '100%';
            p.style.width = '100%';
          }
          const scene = phaserGame && phaserGame.scene && phaserGame.scene.keys && phaserGame.scene.keys.GameScene;
          if (scene && typeof scene.onResizeRebuild === 'function') scene.onResizeRebuild();
          updateUI();
        } catch(e){ console.warn('onResize error', e); }
      }
      window.addEventListener('resize', onResize);
      window.addEventListener('orientationchange', onResize);
      try {
        const ro = new ResizeObserver(onResize);
        const container = document.getElementById('pageWrap');
        if (container) ro.observe(container);
      } catch(e){}

      setTimeout(onResize, 250);

      setupInjectedProviderListeners();
      loadAdsGram();

      // HXN: fetch balance on init and schedule regular refresh
      await fetchHxnBalance();
      setInterval(()=> { fetchHxnBalance(); }, 60e3); // refresh every 60s

      updateUI();
      renderMinersList();
      refreshLeaderboard();
      setInterval(()=>{ refreshLeaderboard(); updateUI(); }, 15000);

      document.addEventListener('visibilitychange', ()=> {
        try {
          if (document.hidden) pauseForHidden();
          else {
            applyOfflineEnergyRecharge();
            resumeFromHidden();
          }
        } catch(e){ console.warn('visibilitychange handler failed', e); }
      });
      window.addEventListener('blur', ()=> { pauseForHidden(); });
      window.addEventListener('focus', ()=> { if (!document.hidden) { applyOfflineEnergyRecharge(); resumeFromHidden(); } });

      window.addEventListener('pagehide', (e) => { try { pauseForHidden(); saveGameToStorage(); saveClientToStorage(); } catch(_) {} }, { passive: true });
      window.addEventListener('beforeunload', (e) => { try { pauseForHidden(); saveGameToStorage(); saveClientToStorage(); } catch(_) {} });

    } catch(err){ console.error('Hexon boot failure:', err); }
  });

  // -----------------------
  // AdsGram loader + showAdAndVerify (REVISED)
  // -----------------------
  let AdsGramLoaded = false, AdController = null;
  function loadAdsGram(){ try { if (window.Adsgram && !AdController){ try{ AdController = window.Adsgram.init({ blockId: ADSGRAM_BLOCK_ID }); AdsGramLoaded = true; return; } catch(e){ console.warn('adsgram init existing', e); } } if (AdsGramLoaded) return; const s = document.createElement('script'); s.src = ADSGRAM_SRC; s.async = true; s.onload = ()=>{ try{ if (window.Adsgram && typeof window.Adsgram.init === 'function'){ AdController = window.Adsgram.init({ blockId: ADSGRAM_BLOCK_ID }); AdsGramLoaded = true; } }catch(e){ console.warn('AdsGram init error', e); } }; s.onerror = ()=>{ console.warn('Failed to load AdsGram SDK'); }; document.head.appendChild(s); } catch(e){ console.warn('loadAdsGram', e); } }

  async function showAdAndVerify(){
    try {
      resetDailyAdsIfNeeded();

      if ((clientState.adsToday||0) >= MAX_ADS_PER_DAY){
        const rem = msUntilNextLocalMidnight();
        showSheet({ title:'Ad', bodyHtml:`<div class="small-muted">Daily ad limit reached. Next reset in <b>${formatMs(rem)}</b>.</div>` });
        return;
      }

      if ((clientState.adsThisSitting||0) >= MAX_ADS_PER_SITTING){
        if (clientState.adsThisSittingStartedAt && (Date.now() - clientState.adsThisSittingStartedAt) < SITTING_COOLDOWN_MS){
          const rem = Math.max(0, SITTING_COOLDOWN_MS - (Date.now() - clientState.adsThisSittingStartedAt));
          showSheet({ title:'Ad', bodyHtml:`<div class="small-muted">Sitting limit reached. Next sitting available in <b>${formatMs(rem)}</b>.</div>` });
          return;
        } else {
          clientState.adsThisSitting = 0;
          clientState.adsThisSittingStartedAt = null;
          saveClientToStorage();
        }
      }

      const timeToNextSitting = timeUntilNextSittingAvailable();
      if (timeToNextSitting > 0){
        const msg = (clientState.sittingsUsedToday || 0) >= MAX_SITTINGS_PER_DAY
                  ? `All sittings used today. Next reset in <b>${formatMs(timeToNextSitting)}</b>.`
                  : `Sitting cooldown active. Next sitting available in <b>${formatMs(timeToNextSitting)}</b>.`;
        showSheet({ title:'Ad', bodyHtml:`<div class="small-muted">${msg}</div>` });
        return;
      }

      showSheet({ title:'Sponsored Transmission', bodyHtml:'<div class="small-muted">Opening sponsored transmission…</div>' });

      startSittingIfNeeded();
      saveClientToStorage();
      updateUI();

      let provider='Fallback', payload={ adSessionId: generateUUID() };
      if (AdsGramLoaded && AdController && typeof AdController.show === 'function'){
        provider='AdsGram';
        try { const result = await AdController.show(); payload={ result }; } catch(err){ showToast('Ad failed / skipped — no reward',1200); hideSheet(); return; }
      } else {
        await new Promise(res=>setTimeout(res,1800));
      }

      const resp = await api('/ad/verify','POST',{ sessionId: clientState.sessionId, provider, payload });
      hideSheet();
      if (resp && resp.grantedPercent){
        setEnergy((clientState.energy || 0) + resp.grantedPercent, true);

        clientState.adsThisSitting = (clientState.adsThisSitting||0) + 1;
        clientState.adsToday = (clientState.adsToday||0) + 1;

        if (clientState.adsThisSitting > MAX_ADS_PER_SITTING){
          clientState.adsThisSitting = MAX_ADS_PER_SITTING;
        }

        if ((clientState.adsThisSitting||0) >= MAX_ADS_PER_SITTING){
          finishSittingAndConsume();
        }

        logAction('ad_watched',{ provider, granted: resp.grantedPercent, adsThisSitting: clientState.adsThisSitting, sittingsUsedToday: clientState.sittingsUsedToday });
        saveClientToStorage();
        updateUI();
        showToast(`Energy credited +${resp.grantedPercent}%`,1200);
        attemptResumeAfterEnergy();
      } else {
        const msg = (resp && resp.error) ? resp.error : 'Ad verification failed';
        showSheet({ title:'Ad', bodyHtml:`<div class="small-muted">${escapeHtml(msg)}</div>` });
      }
    } catch(e){ hideSheet(); console.warn('showAdAndVerify error', e); showToast('Ad error — try later',1200); }
  }

  // -----------------------
  // Small UI sheet helpers
  // -----------------------
  function getSheetElements(){ return { overlay: $('overlay'), sheetBody: $('sheetBody'), sheetTitle: document.querySelector('.sheet-title'), sheetActions: $('sheetActions'), showToast: window._hexon_showToast || ((m,t)=> { const el = $('toast'); if(!el) return; el.textContent = m; el.style.display = 'block'; setTimeout(()=> el.style.display='none', t||2000); }) }; }
  function showSheet({ title='Info', bodyHtml='', actionsHtml='', onMounted=null } = {}){
    const { overlay, sheetBody, sheetTitle, sheetActions } = getSheetElements();
    if (!overlay || !sheetBody || !sheetTitle || !sheetActions){ console.warn('Sheet elements missing'); const { showToast } = getSheetElements(); showToast('UI unavailable', 1200); return; }
    sheetTitle.textContent = title;
    sheetBody.innerHTML = bodyHtml;
    sheetActions.innerHTML = actionsHtml;
    overlay.classList.add('show');
    overlay.setAttribute('aria-hidden','false');
    try{ sheetBody.focus(); }catch(e){}
    if (typeof onMounted === 'function'){ setTimeout(()=> { try{ onMounted(); } catch(e){ console.warn('sheet onMounted error', e); } }, 50); }
  }
  function hideSheet(){ const { overlay } = getSheetElements(); if (!overlay) return; overlay.classList.remove('show'); overlay.setAttribute('aria-hidden','true'); }

  window._hexon_showToast = (m,t)=> { const el = $('toast'); if(!el) return; el.textContent = m; el.style.display = 'block'; setTimeout(()=> el.style.display = 'none', t||2000); };
  </script>
</body>
</html>
