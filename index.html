<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Hexon — Grid (Persistent, Real-time)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;800&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style> /* (unchanged - omitted for brevity here, use your original CSS block) */ </style>
</head>
<body>
  <!-- (HTML body is unchanged; keep the exact structure you had; omitted here for brevity) -->
  <!-- Paste your original body (pageWrap, uiPanel, overlay, toast) here exactly as before -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>

  <script>
  /**
   * Hexon — Real-time enabled (WebSocket primary, HTTP fallback)
   * - WebSocket: wss://<api_base_host>/ws?sessionId=<...>
   * - Fallback HTTP batch flush to: API_BASE + '/game/events' (adjust server-side if different)
   *
   * Notes:
   * - Gameplay loop, physics, drop timing and rendering are unchanged.
   * - Networking runs asynchronously and is throttled so it cannot block input or rendering.
   */

  // -----------------------
  // Config (kept + realtime additions)
  // -----------------------
  const API_BASE = 'https://trainer-induced-beta-estimated.trycloudflare.com';
  const WS_PATH = '/ws'; // server must accept websocket at this path for full real-time
  const WS_RECONNECT_BASE = 800;   // ms base for backoff
  const WS_HEARTBEAT_INTERVAL = 20000; // ms
  const BATCH_FLUSH_INTERVAL = 800; // ms
  const BATCH_MAX_EVENTS = 200;
  const BATCH_HTTP_FALLBACK_PATH = '/game/events'; // fallback batch receiver (server can accept generic events)
  const DAILY_EMISSION_CAP = 1250000;
  const GRID_COLS = 14, GRID_ROWS = 24;
  const BASE_CELL = 20, BASE_GAP = 2;
  const INITIAL_DROP_MS = 800;
  const ADSGRAM_SRC = 'https://sad.adsgram.ai/js/sad.min.js';
  const ADSGRAM_BLOCK_ID = 'int-22823';
  const AUTO_RECHARGE_MINUTES = 30;
  const AUTO_RECHARGE_PERCENT = 10;
  const MAX_ADS_PER_DAY = 9, MAX_ADS_PER_SITTING = 3, MAX_SITTINGS_PER_DAY = 3;

  // -----------------------
  // Persistence keys (unchanged)
  // -----------------------
  const STORAGE_KEYS = {
    CLIENT: 'hexon_client',
    GAME: 'hexon_game',
    SESSION: 'hexon_session',
    BOUND_WALLET: 'hexon_bound_wallet',
    BOUND_PROVIDER: 'hexon_bound_provider',
    PENDING_REF: 'hexon_pending_ref',
    PENDING_DEEPLINK: 'hexon_pending_deeplink'
  };

  // -----------------------
  // State (unchanged base + realtime queue)
  // -----------------------
  let clientState = {
    sessionId: loadSessionFromStorage() || generateUUID(),
    userId: null,
    username: null,
    telegramId: null,
    wallet: loadBoundWalletFromStorage(),
    walletProvider: localStorage.getItem(STORAGE_KEYS.BOUND_PROVIDER) || null,
    gpBase: 0,
    energy: 100,
    miners: [],
    shopItems: [],
    userAU: 0,
    totalAU: 0,
    referralCode: null,
    pendingReferral: null,
    referralsActive: 0,
    adsThisSitting: 0,
    adsToday: 0,
    actionLog: []
  };

  const gameState = {
    grid: null,
    activePiece: null,
    nextPiece: null,
    score: 0,
    level: 1,
    lines: 0,
    dropInterval: INITIAL_DROP_MS,
    isPlaying: false,
    combo: 0,
    lastSavedAt: null,
    lastTickAt: null
  };

  // --- realtime queue & websocket objects ---
  const realtimeQueue = [];
  let ws = null;
  let wsConnected = false;
  let wsBackoff = 0;
  let wsHeartbeatTimer = null;
  let wsReconnectTimer = null;
  let lastFlushAt = 0;
  // throttle map for frequent events
  const lastSent = { tick: 0, move: 0, rotate: 0 };

  saveSessionToStorage(clientState.sessionId);

  // -----------------------
  // Storage helpers (unchanged)...
  // -----------------------
  function loadSessionFromStorage(){ try{return localStorage.getItem(STORAGE_KEYS.SESSION)||null;}catch(e){return null;} }
  function saveSessionToStorage(sid){ try{ if (sid) localStorage.setItem(STORAGE_KEYS.SESSION, sid); }catch(e){} }
  function loadBoundWalletFromStorage(){ try{return localStorage.getItem(STORAGE_KEYS.BOUND_WALLET)||null;}catch(e){return null;} }
  function saveBoundWalletToStorage(pk, provider){ try{ if (pk) localStorage.setItem(STORAGE_KEYS.BOUND_WALLET, pk); if (provider) localStorage.setItem(STORAGE_KEYS.BOUND_PROVIDER, provider); }catch(e){} }
  function clearBoundWalletFromStorage(){ try{ localStorage.removeItem(STORAGE_KEYS.BOUND_WALLET); localStorage.removeItem(STORAGE_KEYS.BOUND_PROVIDER); }catch(e){} }

  function saveClientToStorage(){
    try {
      const toSave = Object.assign({}, clientState);
      toSave.actionLog = (clientState.actionLog || []).slice(-2000);
      localStorage.setItem(STORAGE_KEYS.CLIENT, JSON.stringify(toSave));
    } catch(e){ console.warn('saveClientToStorage error', e); }
  }

  function saveGameToStorage(){
    try {
      const toSave = {
        grid: gameState.grid,
        activePiece: gameState.activePiece,
        nextPiece: gameState.nextPiece,
        score: gameState.score,
        level: gameState.level,
        lines: gameState.lines,
        dropInterval: gameState.dropInterval,
        isPlaying: gameState.isPlaying,
        combo: gameState.combo,
        lastSavedAt: Date.now(),
        lastTickAt: gameState.lastTickAt || Date.now()
      };
      localStorage.setItem(STORAGE_KEYS.GAME, JSON.stringify(toSave));
    } catch(e){ console.warn('saveGameToStorage error', e); }
  }

  function loadClientFromStorage(){
    try {
      const raw = localStorage.getItem(STORAGE_KEYS.CLIENT);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      return parsed;
    } catch(e){ return null; }
  }

  function loadGameFromStorage(){
    try {
      const raw = localStorage.getItem(STORAGE_KEYS.GAME);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      return parsed;
    } catch(e){ return null; }
  }

  function clearSavedGame(){
    try { localStorage.removeItem(STORAGE_KEYS.GAME); } catch(e) {}
  }

  // -----------------------
  // Utilities (unchanged)
  // -----------------------
  function generateUUID(){ try{ if (window.crypto && crypto.randomUUID) return crypto.randomUUID(); }catch(e){} return 'sess-'+Math.floor(Math.random()*1e12).toString(36); }
  function $(id){ return document.getElementById(id); }
  function logAction(a,p={}){ clientState.actionLog.push({t:Date.now(), a, p}); if (clientState.actionLog.length>5000) clientState.actionLog.shift(); saveClientToStorage(); }
  function escapeHtml(str){ return String(str).replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s])); }

  // -----------------------
  // API wrapper (kept, used for non-realtime REST ops)
  // -----------------------
  async function api(path, method='GET', body=null, optsExtra={}){
    try{
      let url = API_BASE + path;
      const sid = clientState.sessionId ? encodeURIComponent(clientState.sessionId) : '';
      if (method.toUpperCase() === 'GET' && sid){
        if (!url.includes('sessionId=')) url += (url.includes('?') ? '&' : '?') + 'sessionId=' + sid;
      }
      const headers = Object.assign({ 'Content-Type': 'application/json' }, optsExtra.headers || {});
      if (clientState.sessionId) headers['X-Session-Id'] = clientState.sessionId;
      const userHandle = clientState.username ? clientState.username : (clientState.telegramId ? ('tg_' + clientState.telegramId) : null);
      if (userHandle) headers['X-User-Handle'] = userHandle;

      const fetchOpts = { method, headers, ...optsExtra };
      if (body !== null && body !== undefined){
        if (typeof body === 'object' && !Array.isArray(body)){
          body.username = body.username || clientState.username || null;
          body.telegramId = body.telegramId || clientState.telegramId || null;
          body.sessionId = body.sessionId || clientState.sessionId || null;
          fetchOpts.body = JSON.stringify(body);
        } else {
          fetchOpts.body = body;
        }
      }

      const res = await fetch(url, fetchOpts);
      const text = await res.text();
      let json = null;
      try { json = text ? JSON.parse(text) : null; } catch(err) { json = text || null; }
      if (!res.ok) { console.warn('API non-ok', res.status, path, json); return json; }
      return json;
    } catch(e){ console.warn('API error', e); return null; }
  }

  // -----------------------
  // Real-time: helpers
  // -----------------------
  function wsUrlForSession(){
    try {
      const base = API_BASE.replace(/^http/, 'ws').replace(/\/+$/,'');
      const sid = encodeURIComponent(clientState.sessionId || '');
      return `${base}${WS_PATH}?sessionId=${sid}`;
    } catch(e){ return null; }
  }

  function ensureWebsocket(){
    if (wsConnected || ws) return;
    const url = wsUrlForSession();
    if (!url) return;
    try {
      ws = new WebSocket(url);
      ws.binaryType = 'arraybuffer';
      ws.onopen = () => {
        wsConnected = true;
        wsBackoff = 0;
        console.log('Realtime WS connected');
        // send handshake
        wsSend({ t:'handshake', ts:Date.now(), sessionId: clientState.sessionId, username: clientState.username || null });
        startHeartbeat();
        flushRealtimeQueue(true);
      };
      ws.onmessage = (evt) => {
        try {
          const data = JSON.parse(evt.data);
          handleServerRealtimeMessage(data);
        } catch(e){ console.warn('ws message parse error', e); }
      };
      ws.onclose = (ev) => {
        wsConnected = false;
        ws = null;
        stopHeartbeat();
        scheduleWsReconnect();
        console.warn('Realtime WS closed', ev && ev.code);
      };
      ws.onerror = (e) => {
        console.warn('Realtime WS error', e);
        // close to trigger reconnect
        try{ ws.close(); } catch(e){}
      };
    } catch(e){
      console.warn('ensureWebsocket failed', e);
      scheduleWsReconnect();
    }
  }

  function scheduleWsReconnect(){
    if (wsReconnectTimer) return;
    wsBackoff = Math.min(60000, wsBackoff ? (wsBackoff * 1.8) : WS_RECONNECT_BASE);
    wsReconnectTimer = setTimeout(()=> { wsReconnectTimer = null; ensureWebsocket(); }, wsBackoff);
  }

  function startHeartbeat(){
    stopHeartbeat();
    wsHeartbeatTimer = setInterval(()=> {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      try{ wsSend({ t:'ping', ts:Date.now() }); } catch(e){ console.warn('ping failed',e); }
    }, WS_HEARTBEAT_INTERVAL);
  }
  function stopHeartbeat(){ if (wsHeartbeatTimer){ clearInterval(wsHeartbeatTimer); wsHeartbeatTimer=null; } }

  function wsSend(msg){
    if (!msg) return;
    const envelope = { s: clientState.sessionId || null, u: clientState.username || null, ts: Date.now(), payload: msg };
    // prefer ws
    try {
      if (ws && ws.readyState === WebSocket.OPEN){
        ws.send(JSON.stringify(envelope));
        return true;
      }
    } catch(e){ console.warn('wsSend error', e); }
    // else queue
    realtimeQueuePush(envelope);
    // attempt to ensure there's a ws connection
    ensureWebsocket();
    return false;
  }

  function realtimeQueuePush(envelope){
    if (!envelope) return;
    realtimeQueue.push(envelope);
    // cap memory
    if (realtimeQueue.length > 5000) realtimeQueue.splice(0, realtimeQueue.length - 5000);
  }

  async function flushRealtimeQueue(forceHttp=false){
    // flush via websocket if available, otherwise send HTTP batch fallback.
    if (ws && ws.readyState === WebSocket.OPEN && realtimeQueue.length){
      try {
        // send up to BATCH_MAX_EVENTS in batch to reduce JSON overhead
        const batch = realtimeQueue.splice(0, BATCH_MAX_EVENTS);
        ws.send(JSON.stringify({ s: clientState.sessionId || null, batch, ts: Date.now() }));
        lastFlushAt = Date.now();
        return true;
      } catch(e){ console.warn('flush via WS failed', e); }
    }

    // HTTP fallback: POST batched events to API_BASE + BATCH_HTTP_FALLBACK_PATH
    if ((forceHttp || realtimeQueue.length) && navigator.onLine){
      try {
        const batch = [];
        while (realtimeQueue.length && batch.length < BATCH_MAX_EVENTS) batch.push(realtimeQueue.shift());
        if (batch.length === 0) return false;
        // send asynchronously without awaiting to avoid blocking UI — but keep a promise to observe failures
        fetch(API_BASE + BATCH_HTTP_FALLBACK_PATH, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-Session-Id': clientState.sessionId || '' },
          body: JSON.stringify({ ts: Date.now(), batch })
        }).then(async (res)=> {
          if (!res.ok) {
            console.warn('batch fallback non-ok', res.status);
            // requeue on failure (prepend)
            realtimeQueue.unshift(...batch);
          } else {
            // optionally parse response for server commands
            try { const j = await res.json(); if (j && j.commands) j.commands.forEach(handleServerRealtimeMessage); } catch(e){}
          }
        }).catch(err => {
          console.warn('batch fallback error', err);
          // requeue on error
          realtimeQueue.unshift(...batch);
        });
        lastFlushAt = Date.now();
        return true;
      } catch(e){ console.warn('HTTP fallback send failed', e); }
    }
    return false;
  }

  // regular background flush
  setInterval(()=> {
    // throttle flush to interval
    if (Date.now() - lastFlushAt < (BATCH_FLUSH_INTERVAL - 20)) return;
    flushRealtimeQueue(false);
  }, BATCH_FLUSH_INTERVAL);

  // on unload, try to send remaining events
  window.addEventListener('beforeunload', ()=> {
    try {
      if (realtimeQueue.length === 0) return;
      const payload = { ts: Date.now(), batch: realtimeQueue.splice(0, realtimeQueue.length) };
      // try sendBeacon (best-effort)
      const url = API_BASE + BATCH_HTTP_FALLBACK_PATH;
      if (navigator.sendBeacon){
        const b = new Blob([JSON.stringify(payload)], { type: 'application/json' });
        navigator.sendBeacon(url, b);
      } else {
        // synchronous XHR fallback
        const xhr = new XMLHttpRequest();
        xhr.open('POST', url, false);
        xhr.setRequestHeader('Content-Type', 'application/json');
        try { xhr.send(JSON.stringify(payload)); } catch(e){}
      }
    } catch(e){ console.warn('beforeunload realtime flush failed', e); }
  });

  function handleServerRealtimeMessage(msg){
    // server can send lightweight commands (e.g., adjust energy, send leaderboard updates)
    if (!msg) return;
    try {
      if (msg.cmd === 'syncClient' && msg.data){
        Object.assign(clientState, msg.data);
        saveClientToStorage();
        updateUI();
      }
      if (msg.cmd === 'forceSave'){ saveClientToStorage(); saveGameToStorage(); }
      if (msg.cmd === 'ping'){ wsSend({ t:'pong', ts:Date.now() }); }
      // handle other commands as you design on server
    } catch(e){ console.warn('handleServerRealtimeMessage err', e); }
  }

  // convenience: queue a logical event (type, payload)
  function realtimeEvent(type, payload={}, opts={priority:false, throttle:0}){
    const now = Date.now();
    if (opts.throttle && (now - (lastSent[type] || 0) < opts.throttle)) return;
    lastSent[type] = now;
    const event = { type, ts: now, payload };
    // high-priority => attempt immediate wsSend
    if (opts.priority){
      if (!wsSend({ t:'event', e:event })) realtimeQueuePush({ t:'event', e:event });
    } else {
      realtimeQueuePush({ t:'event', e:event });
    }
  }

  // -----------------------
  // Telegram init & UI helpers (unchanged)
  // -----------------------
  function initTelegram(){
    try {
      if (window.Telegram && window.Telegram.WebApp){
        const tg = window.Telegram.WebApp;
        try{ if (typeof tg.ready === 'function') tg.ready(); } catch(e){}
        const u = (tg.initDataUnsafe && tg.initDataUnsafe.user) || (tg.initData && tg.initData.user) || null;
        if (u){
          clientState.telegramId = u.id || clientState.telegramId;
          clientState.username = clientState.username || (u.username || `${u.first_name || ''} ${u.last_name || ''}`.trim() || null);
          if (clientState.username) updateUI();
        }
      }
    } catch(e){ console.warn('initTelegram error', e); }
  }

  function getRefFromURL(){ try{ const params = new URLSearchParams(window.location.search); return params.get('ref') || params.get('refCode') || null; } catch(e){ return null; } }
  function savePendingReferral(code){ if (!code) return; try{ localStorage.setItem(STORAGE_KEYS.PENDING_REF, code); clientState.pendingReferral = code; saveClientToStorage(); } catch(e){} }
  function loadPendingReferral(){ try{ const code = localStorage.getItem(STORAGE_KEYS.PENDING_REF); clientState.pendingReferral = code || null; return clientState.pendingReferral; } catch(e){ return null; } }
  function clearPendingReferral(){ try{ localStorage.removeItem(STORAGE_KEYS.PENDING_REF); clientState.pendingReferral = null; saveClientToStorage(); } catch(e){} }

  function showToast(msg, ms=2000){ const el = $('toast'); if(!el) return; el.textContent = msg; el.style.display='block'; setTimeout(()=> el.style.display='none', ms); }

  function renderMinersList(){ const container = $('minersList'); if (!container) return; container.innerHTML=''; if (!clientState.miners || clientState.miners.length===0){ container.innerHTML='<div class="small-muted">No miners owned</div>'; return; } clientState.miners.forEach(m=>{ const node = document.createElement('div'); node.style.display='flex'; node.style.justifyContent='space-between'; node.style.padding='6px 0'; node.innerHTML = `<div><b>${escapeHtml(m.name)}</b><div class="small-muted">Hash ${escapeHtml(String(m.au))} AU</div></div><div class="small-muted">${escapeHtml(m.status||'Active')}</div>`; container.appendChild(node); }); }

  async function refreshLeaderboard(){ const top = await api('/leaderboard/top','GET'); const el = $('leaderboard'); if (!el) return; el.innerHTML=''; if (!top || !Array.isArray(top)){ el.innerHTML = '<div class="small-muted">Leaderboard unavailable</div>'; return; } top.forEach((t,idx)=>{ const row = document.createElement('div'); row.className='leader-entry'; row.style.display='flex'; row.style.justifyContent='space-between'; row.style.padding='6px 0'; row.innerHTML = `<div>${idx+1}. ${escapeHtml(t.name || '—')}</div><div>${(t.score!=null)?Number(t.score).toLocaleString():'—'}</div>`; el.appendChild(row); }); }

  function derivedGPFromScore(score){ return Math.floor((score || 0) / 150); }
  function computeDisplayedGP(){ const base = Number(clientState.gpBase || 0); const derived = derivedGPFromScore(gameState.score || 0); return base + derived; }

  function updateUI(){
    if ($('ui-score')) $('ui-score').innerText = gameState.score || 0;
    if ($('ui-gp')) $('ui-gp').innerText = computeDisplayedGP() + ' GP';
    if ($('ui-energyFill') && $('ui-energyFill').style) $('ui-energyFill').style.width = Math.max(0, Math.min(100, clientState.energy||0)) + '%';
    if ($('ui-level')) $('ui-level').innerText = gameState.level;
    if ($('ui-lines')) $('ui-lines').innerText = gameState.lines;
    if ($('ui-au')) $('ui-au').innerText = 'AU: ' + (clientState.userAU||0).toFixed(2);
    if ($('ui-hxn')) { const est = clientState.totalAU>0 ? ((clientState.userAU / clientState.totalAU) * DAILY_EMISSION_CAP) : 0; $('ui-hxn').innerText = Math.round(est).toLocaleString() + ' HXN'; }
    if ($('ui-username')) { $('ui-username').innerText = clientState.username ? `@${clientState.username}` : (clientState.userId ? `user:${clientState.userId}` : 'Guest'); }
    if ($('ui-session')) { $('ui-session').innerText = clientState.sessionId || '—'; }
    if ($('ui-wallet')) { $('ui-wallet').innerText = clientState.wallet ? clientState.wallet : 'Not connected'; }
    if ($('ui-provider')) { $('ui-provider').innerText = clientState.walletProvider ? clientState.walletProvider : '—'; }
    if ($('ui-adsToday')) $('ui-adsToday').innerText = String(clientState.adsToday||0);
    if ($('ui-sittings')) $('ui-sittings').innerText = `${MAX_SITTINGS_PER_DAY}/${MAX_SITTINGS_PER_DAY}`;
  }

  // -----------------------
  // Pieces & core logic (kept; only calls to realtimeEvent added)
  // -----------------------
  const PIECES = {
    I: [[[0,1],[1,1],[2,1],[3,1]], [[2,0],[2,1],[2,2],[2,3]], [[0,2],[1,2],[2,2],[3,2]], [[1,0],[1,1],[1,2],[1,3]]],
    J: [[[0,0],[0,1],[1,1],[2,1]], [[1,0],[2,0],[1,1],[1,2]], [[0,1],[1,1],[2,1],[2,2]], [[1,0],[1,1],[0,2],[1,2]]],
    L: [[[2,0],[0,1],[1,1],[2,1]], [[1,0],[1,1],[1,2],[2,2]], [[0,1],[1,1],[2,1],[0,2]], [[0,0],[1,0],[1,1],[1,2]]],
    O: [[[1,0],[2,0],[1,1],[2,1]]],
    S: [[[1,0],[2,0],[0,1],[1,1]], [[1,0],[1,1],[2,1],[2,2]]],
    T: [[[1,0],[0,1],[1,1],[2,1]], [[1,0],[1,1],[2,1],[1,2]], [[0,1],[1,1],[2,1],[1,2]], [[1,0],[0,1],[1,1],[1,2]]],
    Z: [[[0,0],[1,0],[1,1],[2,1]], [[2,0],[1,1],[2,1],[1,2]]]
  };
  const PIECE_TYPES = Object.keys(PIECES);

  let phaserGame;
  let CELL = BASE_CELL, GAP = BASE_GAP;

  class BootScene extends Phaser.Scene { constructor(){ super({ key:'BootScene' }); } create(){ this.scene.start('GameScene'); } }
  class GameScene extends Phaser.Scene {
    constructor(){ super({ key:'GameScene' }); }
    create(){
      this.boardPixelWidth = GRID_COLS * (CELL + GAP) + 40;
      this.boardPixelHeight = GRID_ROWS * (CELL + GAP) + 40;
      this.gridOrigin = { x:16, y:16 };

      const g = this.add.graphics();
      g.fillStyle(0x061426,1);
      g.fillRoundedRect(this.gridOrigin.x -8, this.gridOrigin.y -8, this.boardPixelWidth, this.boardPixelHeight, 10);
      g.lineStyle(1, 0x0d2130, 0.6);
      for (let r=0;r<=GRID_ROWS;r++) g.strokeLineShape(new Phaser.Geom.Line(this.gridOrigin.x, this.gridOrigin.y + r*(CELL+GAP), this.gridOrigin.x + GRID_COLS*(CELL+GAP), this.gridOrigin.y + r*(CELL+GAP)));
      for (let c=0;c<=GRID_COLS;c++) g.strokeLineShape(new Phaser.Geom.Line(this.gridOrigin.x + c*(CELL+GAP), this.gridOrigin.y, this.gridOrigin.x + c*(CELL+GAP), this.gridOrigin.y + GRID_ROWS*(CELL+GAP)));

      if (!gameState.grid) initGrid();
      if (!gameState.activePiece) spawnPiece();

      this.cellSprites = Array.from({ length: GRID_ROWS }, () => Array(GRID_COLS).fill(null));
      for (let r=0;r<GRID_ROWS;r++){
        for (let c=0;c<GRID_COLS;c++){
          const x = this.gridOrigin.x + c*(CELL+GAP) + CELL/2;
          const y = this.gridOrigin.y + r*(CELL+GAP) + CELL/2;
          const rect = this.add.rectangle(x,y,CELL,CELL,0x102033).setStrokeStyle(1,0x092033,0.6);
          rect.updateFill = function(color){ try{ this.fillColor = color; }catch(e){} try{ if (typeof this.setFillStyle === 'function') this.setFillStyle(color); }catch(e){} };
          rect.setInteractive({ useHandCursor: true });
          ((rr,cc,node)=> node.on('pointerdown', ()=> { vibratePreferTelegram(); logAction('cell_click',{x:cc,y:rr}); const orig = node.fillColor || 0x102033; node.updateFill(0xFFFFFF); this.time.delayedCall(80, ()=> node.updateFill(orig)); }))(r,c,rect);
          this.cellSprites[r][c] = rect;
        }
      }

      gameState.isPlaying = gameState.isPlaying !== undefined ? gameState.isPlaying : true;
      updateUI();
      this.catchUpMissedTicks();
      this.startDropLoop();
      this.setupInput();
      this.time.addEvent({ delay: AUTO_RECHARGE_MINUTES * 60e3, callback: this.autoRecharge, callbackScope: this, loop: true });
      this.saveInterval = this.time.addEvent({ delay: 2000, loop:true, callback: ()=> { gameState.lastTickAt = Date.now(); saveGameToStorage(); saveClientToStorage(); } });
    }

    startDropLoop(){
      if (this.dropEvent){ try{ this.dropEvent.remove(false); }catch(e){} this.dropEvent=null; }
      const delay = Math.max(40, gameState.dropInterval || INITIAL_DROP_MS);
      this.dropEvent = this.time.addEvent({ delay, loop: true, callback: ()=> { if (!gameState.isPlaying) return; const moved = movePieceDown(); logAction('tick_drop',{ moved }); // realtime tick event (throttle)
          realtimeEvent('tick', { moved, piece: snapshotActivePiece(), score: gameState.score, lines: gameState.lines }, { priority:false, throttle:150 });
          if (!moved) {
            lockPiece();
          }
          gameState.lastTickAt = Date.now(); saveGameToStorage(); updateUI(); } });
    }

    update(){ if (!gameState.isPlaying) return; this.renderGrid(); }

    renderGrid(){
      for (let r=0;r<GRID_ROWS;r++) for (let c=0;c<GRID_COLS;c++){ const val = gameState.grid[r][c]; const color = val ? colorFromVal(val) : 0x102033; const rect = this.cellSprites[r][c]; if (rect && typeof rect.updateFill === 'function') rect.updateFill(color); }
      if (gameState.activePiece){
        const cells = getPieceCells(gameState.activePiece);
        cells.forEach(p => { if (p.y>=0 && p.y<GRID_ROWS && p.x>=0 && p.x<GRID_COLS){ const rect = this.cellSprites[p.y][p.x]; if (rect && typeof rect.updateFill === 'function') rect.updateFill(colorFromVal(gameState.activePiece.type)); } });
      }
    }

    setupInput(){
      this.input.keyboard.on('keydown', (ev)=>{ if (!gameState.isPlaying) return; handleKey(ev.code || ev.key); });
      window.addEventListener('keydown', (ev)=>{ if (!gameState.isPlaying) return; handleKey(ev.code || ev.key); });
      if (!document.querySelector('.touch-controls')) setupTouchControls(this);
    }

    autoRecharge(){ clientState.energy = Math.min(100, clientState.energy + AUTO_RECHARGE_PERCENT); updateUI(); logAction('auto_recharge', { energy: clientState.energy }); realtimeEvent('auto_recharge',{ energy: clientState.energy }, { priority:true }); saveClientToStorage(); }
    catchUpMissedTicks(){
      try {
        if (!gameState.lastTickAt || !gameState.isPlaying) return;
        const now = Date.now();
        const elapsed = Math.max(0, now - gameState.lastTickAt);
        const di = Math.max(40, gameState.dropInterval || INITIAL_DROP_MS);
        const ticks = Math.floor(elapsed / di);
        if (!ticks) return;
        for (let i=0;i<ticks;i++){
          if (!gameState.isPlaying) break;
          const moved = movePieceDown();
          if (!moved){
            lockPiece();
            if (!gameState.isPlaying) break;
          }
        }
        gameState.lastTickAt = now;
        saveGameToStorage();
      } catch(e){ console.warn('catchUpMissedTicks error', e); }
    }
  }

  function handleKey(code){ switch(code){ case 'ArrowLeft': case 'Left': movePiece(-1); break; case 'ArrowRight': case 'Right': movePiece(1); break; case 'ArrowDown': case 'Down': softDrop(); break; case 'Space': case ' ': hardDrop(); break; case 'ArrowUp': case 'Up': rotatePiece(); break; default: return; } updateUI(); saveGameToStorage(); saveClientToStorage(); realtimeEvent('input', { key: code, score: gameState.score }, { throttle:120 }); }
  function getPieceCells(piece){ const states = PIECES[piece.type]; const state = states[piece.rot % states.length]; return state.map(p => ({ x:p[0] + piece.x, y:p[1] + piece.y })); }

  function snapshotActivePiece(){
    if (!gameState.activePiece) return null;
    return { type: gameState.activePiece.type, rot: gameState.activePiece.rot, x: gameState.activePiece.x, y: gameState.activePiece.y };
  }

  function initGrid(){ gameState.grid = Array.from({ length: GRID_ROWS }, ()=> Array(GRID_COLS).fill(0)); gameState.score = 0; gameState.level = 1; gameState.lines = 0; gameState.combo = 0; gameState.dropInterval = INITIAL_DROP_MS; gameState.isPlaying = true; gameState.lastSavedAt = Date.now(); gameState.lastTickAt = Date.now(); saveGameToStorage(); realtimeEvent('init', { score: gameState.score, level: gameState.level }, { priority:true }); }

  function spawnPiece(){
    if ((clientState.energy||0) <= 0){
      gameState.isPlaying=false;
      showSheet({ title:'Energy', bodyHtml:'<div class="small-muted">Out of energy — watch an ad or wait for recharge.</div>' });
      saveGameToStorage();
      return;
    }
    const type = PIECE_TYPES[Math.floor(Math.random()*PIECE_TYPES.length)];
    const xStart = Math.floor((GRID_COLS - 4)/2);
    gameState.activePiece = { type, rot:0, x:xStart, y:0 };
    gameState.nextPiece = PIECE_TYPES[Math.floor(Math.random()*PIECE_TYPES.length)];
    logAction('spawn',{ type, x:xStart, y:0 });
    realtimeEvent('spawn',{ type, x:xStart, y:0, energy: clientState.energy }, { throttle:200 });
    if (checkCollision(getPieceCells(gameState.activePiece))) {
      gameOver();
    } else {
      gameState.lastTickAt = Date.now();
      saveGameToStorage();
    }
  }

  function checkCollision(cells){ for (const p of cells){ if (p.x < 0 || p.x >= GRID_COLS) return true; if (p.y >= GRID_ROWS) return true; if (p.y >= 0 && gameState.grid[p.y][p.x]) return true; } return false; }
  function movePiece(dir){ if (!gameState.activePiece) return; const cand = { ...gameState.activePiece, x: gameState.activePiece.x + dir }; if (!checkCollision(getPieceCells(cand))){ gameState.activePiece.x = cand.x; logAction('move',{ dir }); saveGameToStorage(); realtimeEvent('move',{ dir, piece: snapshotActivePiece() }, { throttle:80 }); } }

  function movePieceDown(){ if (!gameState.activePiece) return false; const cand = { ...gameState.activePiece, y: gameState.activePiece.y + 1 }; if (!checkCollision(getPieceCells(cand))){ gameState.activePiece.y = cand.y; return true; } return false; }

  function softDrop(){ if (movePieceDown()){ gameState.score += 1; logAction('soft_drop'); updateUI(); saveGameToStorage(); realtimeEvent('soft_drop',{ piece: snapshotActivePiece(), score: gameState.score }, { throttle:60 }); } }

  function hardDrop(){ let falls=0; while(movePieceDown()) falls++; lockPiece(); gameState.score += falls * 2; logAction('hard_drop',{ falls }); updateUI(); saveGameToStorage(); realtimeEvent('hard_drop',{ falls, score: gameState.score }, { priority:true }); }

  function rotatePiece(){ if (!gameState.activePiece) return; const candidate = { ...gameState.activePiece, rot: (gameState.activePiece.rot + 1) }; const kicks = [{dx:0,dy:0},{dx:-1,dy:0},{dx:1,dy:0},{dx:-2,dy:0},{dx:2,dy:0},{dx:0,dy:-1}]; for (const k of kicks){ const cand = { ...candidate, x: candidate.x + k.dx, y: candidate.y + k.dy }; if (!checkCollision(getPieceCells(cand))){ gameState.activePiece.rot = cand.rot; gameState.activePiece.x = cand.x; gameState.activePiece.y = cand.y; logAction('rotate',{ rot:cand.rot, kick:k }); saveGameToStorage(); realtimeEvent('rotate',{ rot:cand.rot, kick:k, piece: snapshotActivePiece() }, { throttle:120 }); return; } } }

  function lockPiece(){
    const ap = gameState.activePiece; if (!ap) return;
    const cells = getPieceCells(ap);
    for (const p of cells){ if (p.y >= 0 && p.y < GRID_ROWS && p.x >= 0 && p.x < GRID_COLS){ gameState.grid[p.y][p.x] = ap.type; } }
    clientState.energy = Math.max(0, (clientState.energy || 0) - 1);
    const cleared = [];
    for (let r=0;r<GRID_ROWS;r++) if (gameState.grid[r].every(v=>v!==0)) cleared.push(r);
    if (cleared.length > 0) clearLines(cleared); else gameState.combo = 0;
    gameState.activePiece = null;
    spawnPiece();
    try{ const scene = phaserGame && phaserGame.scene && phaserGame.scene.keys && phaserGame.scene.keys.GameScene; if (scene && typeof scene.startDropLoop === 'function') scene.startDropLoop(); }catch(e){}
    saveClientToStorage();
    saveGameToStorage();
    updateUI();
    // high priority event: locked & snapshot of grid diff (lightweight)
    realtimeEvent('lock', { piece: ap, clearedRows: cleared.slice(), energy: clientState.energy, score: gameState.score }, { priority:true });
  }

  function clearLines(rows){
    rows.sort((a,b)=>a-b);
    for (const r of rows){ gameState.grid.splice(r,1); gameState.grid.unshift(Array(GRID_COLS).fill(0)); }
    const count = rows.length; const base = [0,100,300,500,800];
    gameState.score += base[count] * gameState.level;
    gameState.lines += count; gameState.combo += 1;
    logAction('clear',{ count, combo:gameState.combo });
    // notify server immediately about lines cleared (important)
    realtimeEvent('clear', { count, combo: gameState.combo, score: gameState.score, lines: gameState.lines }, { priority:true });
    if (gameState.lines % 10 === 0){ gameState.level++; gameState.dropInterval = Math.max(120, Math.floor(gameState.dropInterval * 0.92)); }
    saveGameToStorage();
    updateUI();
  }

  async function gameOver(){
    gameState.isPlaying = false;
    logAction('gameover',{ score:gameState.score, lines:gameState.lines });
    // send final score immediately (via ws if available or via REST)
    realtimeEvent('gameover', { score:gameState.score, lines:gameState.lines, actionLog: clientState.actionLog.slice(-2000) }, { priority:true });
    // also do your existing /game/submit-score REST call for compatibility
    try{ await api('/game/submit-score','POST',{ sessionId: clientState.sessionId, score: gameState.score, lines: gameState.lines, actionLog: clientState.actionLog.slice(-2000) }); } catch(e){ console.warn(e); }
    showSheet({ title:'Game Over', bodyHtml:`<div style="font-weight:700">Game Over</div><div class="small-muted">Score ${gameState.score} • Lines ${gameState.lines}</div>`, actionsHtml:`<button id="playAgain" class="button"><i class="fa-solid fa-rotate"></i> Play Again</button><button id="closeOver" class="btn-ghost">Close</button>`, onMounted: ()=>{ const p=$('playAgain'); if (p) p.onclick = ()=> { hideSheet(); resetForPlay(); }; const c=$('closeOver'); if (c) c.onclick = hideSheet; }});
    saveGameToStorage();
    saveClientToStorage();
    updateUI();
  }

  function resetForPlay(){
    initGrid();
    gameState.dropInterval = INITIAL_DROP_MS;
    clientState.actionLog = [];
    clientState.energy = Math.max(0, clientState.energy);
    spawnPiece();
    gameState.isPlaying = true;
    clearSavedGame();
    saveClientToStorage();
    updateUI();
    try{ const scene = phaserGame && phaserGame.scene && phaserGame.scene.keys && phaserGame.scene.keys.GameScene; if (scene && typeof scene.startDropLoop === 'function') scene.startDropLoop(); }catch(e){}
  }

  function colorFromVal(val){ const map = { I:0x22d3ee, J:0x7c3aed, L:0xf59e0b, O:0xfacc15, S:0x10b981, T:0x8b5cf6, Z:0xef4444 }; return map[val] ?? 0x0f172a; }

  function setupTouchControls(scene){
    if (document.querySelector('.touch-controls')) return;
    const wrapper = document.createElement('div'); wrapper.classList.add('touch-controls');
    const btnLeft = document.createElement('div'); btnLeft.className='touch-btn'; btnLeft.innerHTML = '<i class="fa-solid fa-arrow-left"></i>';
    const btnRight = document.createElement('div'); btnRight.className='touch-btn'; btnRight.innerHTML = '<i class="fa-solid fa-arrow-right"></i>';
    const btnRotate = document.createElement('div'); btnRotate.className='touch-btn'; btnRotate.innerHTML = '<i class="fa-solid fa-rotate"></i>';
    const btnDown = document.createElement('div'); btnDown.className='touch-btn'; btnDown.innerHTML = '<i class="fa-solid fa-arrow-down"></i>';
    [btnLeft, btnRotate, btnDown, btnRight].forEach(b=>{ b.style.padding='10px'; b.style.borderRadius='8px'; b.style.background='rgba(255,255,255,0.04)'; });
    wrapper.append(btnLeft, btnRotate, btnDown, btnRight);
    const ui = $('uiPanel'); if (ui) ui.append(wrapper);
    btnLeft.onclick = ()=>{ movePiece(-1); vibratePreferTelegram(); logAction('touch_left'); updateUI(); saveGameToStorage(); realtimeEvent('touch_left',{ piece: snapshotActivePiece() },{ throttle:120 }); };
    btnRight.onclick = ()=>{ movePiece(1); vibratePreferTelegram(); logAction('touch_right'); updateUI(); saveGameToStorage(); realtimeEvent('touch_right',{ piece: snapshotActivePiece() },{ throttle:120 }); };
    btnRotate.onclick = ()=>{ rotatePiece(); vibratePreferTelegram(); logAction('touch_rotate'); updateUI(); saveGameToStorage(); realtimeEvent('touch_rotate',{ piece: snapshotActivePiece() },{ throttle:120 }); };
    btnDown.onclick = ()=>{ softDrop(); vibratePreferTelegram(); logAction('touch_drop'); updateUI(); saveGameToStorage(); realtimeEvent('touch_drop',{ piece: snapshotActivePiece() },{ throttle:80 }); };
  }

  function vibratePreferTelegram(){ try{ const tg = (window.Telegram && window.Telegram.WebApp) ? window.Telegram.WebApp : null; if (tg && typeof tg.triggerHapticFeedback === 'function'){ tg.triggerHapticFeedback('selection_change'); return; } }catch(e){} if (navigator && typeof navigator.vibrate === 'function') navigator.vibrate(20); }

  // -----------------------
  // Wallet / deep-linking code (kept; realtime events added when binding)
  // -----------------------
  function detectInjectedProviders(){
    const solana = window.solana || null;
    return {
      phantom: Boolean((solana && solana.isPhantom) || (window.phantom && window.phantom.isPhantom)),
      solflare: Boolean(window.solflare || (solana && solana.isSolflare)),
      backpack: Boolean(window.backpack || (solana && solana.isBackpack)),
      anySolana: Boolean(solana || window.solflare || window.backpack || window.phantom)
    };
  }

  function setPendingDeepLink(providerName){
    try { localStorage.setItem(STORAGE_KEYS.PENDING_DEEPLINK, JSON.stringify({ provider: providerName, ts: Date.now() })); } catch(e){}
  }
  function clearPendingDeepLink(){ try{ localStorage.removeItem(STORAGE_KEYS.PENDING_DEEPLINK); }catch(e){} }
  function getPendingDeepLink(){ try{ const s = localStorage.getItem(STORAGE_KEYS.PENDING_DEEPLINK); return s ? JSON.parse(s) : null; }catch(e){return null;} }

  function openDeepLinkAndWait({ deepLink, installUrl, appName, providerName }){
    return new Promise((resolve) => {
      setPendingDeepLink(providerName || 'unknown');
      const tg = (window.Telegram && window.Telegram.WebApp) ? window.Telegram.WebApp : null;
      try {
        if (tg && typeof tg.openUrl === 'function'){
          tg.openUrl(deepLink);
        } else {
          window.location.assign(deepLink);
        }
      } catch (e) {
        try { window.open(deepLink, '_self'); } catch(e2){ console.warn('open deep link failed', e2); }
      }

      showSheet({
        title: `Opening ${appName}`,
        bodyHtml: `<div class="small-muted">Opening ${escapeHtml(appName)} — return to this page after approving. Waiting for a response…</div><div style="margin-top:8px;" class="small-muted">If the app didn't open, choose "Try open" or install.</div>`,
        actionsHtml: `<button id="tryOpenNow" class="button">Try open ${escapeHtml(appName)}</button><button id="installApp" class="btn-ghost">Install ${escapeHtml(appName)}</button><button id="cancelWait" class="btn-ghost">Cancel</button>`,
        onMounted: ()=>{
          const tryOpen = $('tryOpenNow'); if (tryOpen) tryOpen.onclick = ()=>{ try{ window.location.assign(deepLink); }catch(e){ window.open(deepLink, '_blank'); } };
          const install = $('installApp'); if (install) install.onclick = ()=>{ try{ window.open(installUrl || deepLink, '_blank'); }catch(e){ try{ window.location.assign(installUrl || deepLink); }catch(_){} } };
          const cancel = $('cancelWait'); if (cancel) cancel.onclick = ()=>{ hideSheet(); clearPendingDeepLink(); resolve(false); };
        }
      });

      const start = Date.now();
      const interval = setInterval(async ()=>{
        const pk = parseReturnParams();
        if (pk && isValidSolanaPublicKey(pk)){
          clearInterval(interval);
          try { hideSheet(); } catch(e){}
          clearPendingDeepLink();
          const ok = await bindWalletWithPublicKey(pk, providerName);
          resolve(Boolean(ok));
          return;
        }
        if (Date.now() - start > 90000){
          clearInterval(interval);
          hideSheet();
          resolve(false);
          return;
        }
      }, 700);
    });
  }

  function phantomDeepLink(){ try { const origin = window.location.origin.replace(/\/+$/,''); return `https://phantom.app/ul/v1/authorize?app_url=${encodeURIComponent(origin)}&redirect_link=${encodeURIComponent(origin + window.location.pathname)}`; }catch(e){ return `https://phantom.app/`; } }
  function solflareDeepLink(){ try { const redirect = encodeURIComponent(window.location.origin.replace(/\/+$/,'') + window.location.pathname); return `https://solflare.com/access?redirect=${redirect}`; } catch(e){ return `https://solflare.com/`; } }
  function backpackDeepLink(){ return 'https://backpack.app/'; }

  async function connectWithPhantom(){
    const detected = detectInjectedProviders();
    if (window.solana && window.solana.isPhantom){
      try {
        const resp = await window.solana.connect();
        const publicKey = extractPublicKeyFromProviderResponse(resp);
        if (publicKey && isValidSolanaPublicKey(publicKey)){
          const ok = await finalizeBind(publicKey, 'phantom');
          return Boolean(ok);
        }
      } catch(e){ console.warn('phantom injected connect failed', e); }
    }
    const deep = phantomDeepLink();
    setPendingDeepLink('phantom');
    const ok = await openDeepLinkAndWait({ deepLink: deep, installUrl: 'https://phantom.app/', appName: 'Phantom', providerName: 'phantom' });
    return Boolean(ok);
  }

  async function connectWithSolflare(){
    const detected = detectInjectedProviders();
    if (window.solflare && typeof window.solflare.connect === 'function'){
      try {
        const resp = await window.solflare.connect();
        const publicKey = extractPublicKeyFromProviderResponse(resp);
        if (publicKey && isValidSolanaPublicKey(publicKey)){
          const ok = await finalizeBind(publicKey, 'solflare');
          return Boolean(ok);
        }
      } catch(e){ console.warn('solflare injected failed', e); }
    }
    if (window.solana && window.solana.isSolflare){
      try {
        const r = await window.solana.connect();
        const publicKey = extractPublicKeyFromProviderResponse(r);
        if (publicKey && isValidSolanaPublicKey(publicKey)){
          const ok = await finalizeBind(publicKey, 'solflare');
          return Boolean(ok);
        }
      } catch(e){ console.warn('solflare via solana failed', e); }
    }
    const deep = solflareDeepLink();
    setPendingDeepLink('solflare');
    const ok = await openDeepLinkAndWait({ deepLink: deep, installUrl: 'https://solflare.com/', appName: 'Solflare', providerName: 'solflare' });
    return Boolean(ok);
  }

  async function connectWithBackpack(){
    const detected = detectInjectedProviders();
    if (window.backpack && typeof window.backpack.connect === 'function'){
      try {
        const resp = await window.backpack.connect();
        const publicKey = extractPublicKeyFromProviderResponse(resp);
        if (publicKey && isValidSolanaPublicKey(publicKey)){
          const ok = await finalizeBind(publicKey, 'backpack');
          return Boolean(ok);
        }
      } catch(e){ console.warn('backpack injected failed', e); }
    }
    if (window.solana && window.solana.isBackpack){
      try{
        const r = await window.solana.connect();
        const publicKey = extractPublicKeyFromProviderResponse(r);
        if (publicKey && isValidSolanaPublicKey(publicKey)){
          const ok = await finalizeBind(publicKey, 'backpack');
          return Boolean(ok);
        }
      } catch(e){}
    }
    const deep = backpackDeepLink();
    setPendingDeepLink('backpack');
    const ok = await openDeepLinkAndWait({ deepLink: deep, installUrl: 'https://backpack.app/', appName: 'Backpack', providerName: 'backpack' });
    return Boolean(ok);
  }

  async function connectWithWalletConnect(){
    try {
      if (window.SOL_WALLETCONNECT_CONNECTOR && typeof window.SOL_WALLETCONNECT_CONNECTOR.connect === 'function'){
        const pk = await window.SOL_WALLETCONNECT_CONNECTOR.connect({ redirect: buildCleanRedirect() });
        if (pk) {
          const ok = await finalizeBind(pk, 'walletconnect');
          return Boolean(ok);
        }
      }
      showSheet({ title:'WalletConnect', bodyHtml:`<div class="small-muted">No helper available. Open your mobile wallet and use WalletConnect; then paste the returned public key below.</div><div style="margin-top:8px;"><input id="wcManual" style="width:100%; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.06)" placeholder="Paste public key" /></div>`, actionsHtml:`<button id="wcBind" class="button">Bind</button><button id="wcClose" class="btn-ghost">Close</button>`, onMounted: ()=> {
        const b = $('wcBind'); const c = $('wcClose');
        if (b){ b.onclick = async ()=> { const pk = ($('wcManual').value||'').trim(); if (!pk) return alert('Paste public key'); hideSheet(); const ok = await finalizeBind(pk, 'walletconnect'); if (!ok) showToast('Bind failed',1200); }; }
        if (c) c.onclick = hideSheet;
      }});
      return false;
    } catch(e){ console.warn('connectWithWalletConnect failed', e); return false; }
  }

  window.connectWithPhantom = connectWithPhantom;
  window.connectWithSolflare = connectWithSolflare;
  window.connectWithBackpack = connectWithBackpack;
  window.connectWithWalletConnect = connectWithWalletConnect;
  window.openPhantomDeepLink = () => openDeepLinkAndWait({ deepLink: phantomDeepLink(), installUrl: 'https://phantom.app/', appName: 'Phantom', providerName: 'phantom' });
  window.openSolflareDeepLink = () => openDeepLinkAndWait({ deepLink: solflareDeepLink(), installUrl: 'https://solflare.com/', appName: 'Solflare', providerName: 'solflare' });
  window.openBackpackDeepLink = () => openDeepLinkAndWait({ deepLink: backpackDeepLink(), installUrl: 'https://backpack.app/', appName: 'Backpack', providerName: 'backpack' });
  window.showWalletPicker = function(){ showSheet({ title:'Connect Wallet', bodyHtml: $('sheetBody').innerHTML }); };

  async function bindWalletWithPublicKey(publicKey, providerName){
    try {
      const payload = { sessionId: clientState.sessionId, wallet: publicKey, walletProvider: providerName||null, referral: clientState.pendingReferral || clientState.referralCode || null, username: clientState.username, telegramId: clientState.telegramId };
      const res = await api('/wallet/bind','POST', payload);
      // immediate realtime event about wallet bind
      realtimeEvent('wallet_bind', { wallet: publicKey, provider: providerName || null }, { priority:true });
      if (res && res.ok){
        if (res.sessionId && res.sessionId !== clientState.sessionId){ clientState.sessionId = res.sessionId; saveSessionToStorage(clientState.sessionId); }
        clientState.wallet = publicKey;
        clientState.userId = res.userId ?? clientState.userId;
        clientState.gpBase = res.gp ?? clientState.gpBase;
        clientState.miners = res.miners ?? clientState.miners;
        clientState.userAU = res.userAU ?? clientState.userAU;
        clientState.totalAU = res.totalAU ?? clientState.totalAU;
        clientState.referralCode = res.referralCode ?? clientState.referralCode;
        clientState.referralsActive = res.referralsActive ?? clientState.referralsActive;
        if (res.referralAccepted) clearPendingReferral();
        saveBoundWalletToStorage(publicKey, providerName || clientState.walletProvider || null);
        saveClientToStorage();
        updateUI(); renderMinersList();
        return true;
      }
      return false;
    } catch(e){ console.warn('bindWalletWithPublicKey error', e); return false; }
  }

  window.finalizeBind = async function(publicKey, providerName){
    if (!publicKey) { showSheet({ title:'Wallet', bodyHtml:'<div class="small-muted">No public key provided</div>' }); setTimeout(hideSheet, 900); return false; }
    if (!isValidSolanaPublicKey(publicKey)) { showSheet({ title:'Wallet', bodyHtml:'<div class="small-muted">Public key format invalid</div>' }); setTimeout(hideSheet, 900); return false; }
    clientState.walletProvider = providerName || clientState.walletProvider || null;
    const ok = await bindWalletWithPublicKey(publicKey, providerName);
    if (ok){
      clientState.wallet = publicKey;
      clientState.walletProvider = providerName;
      saveBoundWalletToStorage(publicKey, providerName);
      updateUI();
      hideSheet();
      showToast(`Wallet connected (${providerName || 'manual'})`, 1000);
      return true;
    } else {
      showSheet({ title:'Wallet', bodyHtml:`<div class="small-muted">Server bind failed for ${escapeHtml(providerName || 'wallet')}</div>`, actionsHtml:`<button id="retryBind" class="button">Try again</button><button id="closeBind" class="btn-ghost">Close</button>`, onMounted: ()=> { const r=$('retryBind'); if (r) r.onclick = ()=> { hideSheet(); showSheet({ title:'Connect Wallet' }); }; const c=$('closeBind'); if (c) c.onclick = hideSheet; }});
      return false;
    }
  };

  function parseReturnParams(){
    try {
      let combined = window.location.search || '';
      if (window.location.hash){
        const h = window.location.hash.replace(/^#/,'');
        if (h.indexOf('?') !== -1) combined += (combined ? '&' : '') + h.split('?').slice(1).join('?');
        else combined += (combined ? '&' : '') + h;
      }
      const params = new URLSearchParams(combined);
      const names = ['phantom_public_key','phantom_encryption_public_key','public_key','publicKey','public-key','wallet','pk','address','account','account_id','publicKeyBase58'];
      for (const n of names){ const v = params.get(n); if (v) return v; }
      const raw = params.get('result') || params.get('response') || params.get('data');
      if (raw){
        try {
          const parsed = JSON.parse(raw);
          if (parsed && (parsed.publicKey || parsed.address || parsed.pk)) return parsed.publicKey || parsed.address || parsed.pk;
          for (const k of Object.keys(parsed || {})){
            const val = parsed[k];
            if (typeof val === 'string' && isValidSolanaPublicKey(val)) return val;
          }
        } catch(e){}
      }
      const full = window.location.href;
      const match = full.match(/([1-9A-HJ-NP-Za-km-z]{32,64})/);
      if (match) return match[1];
      return null;
    } catch(e){ return null; }
  }

  function readWalletReturn(){
    try {
      const pk = parseReturnParams();
      if (pk){
        (async ()=> {
          if (!isValidSolanaPublicKey(pk)){ showSheet({ title:'Wallet', bodyHtml:'<div class="small-muted">Returned public key appears invalid</div>' }); setTimeout(hideSheet,1200); return; }
          const pending = getPendingDeepLink();
          const provider = pending && pending.provider ? pending.provider : null;
          const ok = await bindWalletWithPublicKey(pk, provider);
          try { const cleanUrl = window.location.origin + window.location.pathname; history.replaceState({}, document.title, cleanUrl); } catch(e){}
          clearPendingDeepLink();
          if (ok) { clearPendingReferral(); showToast('Wallet connected',1000); } else { showSheet({ title:'Wallet', bodyHtml:'<div class="small-muted">Wallet connect failed — open app and try again</div>' }); setTimeout(hideSheet,1200); }
        })();
        return true;
      }
      return false;
    } catch(e){ console.warn('readWalletReturn error', e); return false; }
  }

  function setupInjectedProviderListeners(){
    try {
      if (window.solana && typeof window.solana.on === 'function'){
        try {
          window.solana.on('connect', async (pk) => {
            try {
              const publicKey = (pk && pk.toString) ? pk.toString() : (pk && pk.publicKey && pk.publicKey.toString ? pk.publicKey.toString() : pk);
              if (publicKey && (!clientState.wallet || clientState.wallet !== publicKey)){
                const det = detectInjectedProviders();
                clientState.walletProvider = det.phantom ? 'phantom' : (det.solflare ? 'solflare' : (det.backpack ? 'backpack' : clientState.walletProvider));
                const ok = await bindWalletWithPublicKey(publicKey, clientState.walletProvider);
                if (ok) showToast('Wallet connected',900);
              }
            } catch(e){ console.warn('provider connect handler error', e); }
          });
          window.solana.on('disconnect', () => { clientState.wallet = null; clientState.walletProvider = null; clearBoundWalletFromStorage(); updateUI(); saveClientToStorage(); });
        } catch(e){ console.warn('solana listener setup failed', e); }
      }

      if (window.solflare && typeof window.solflare.on === 'function'){
        try {
          window.solflare.on('connect', async (pk) => {
            const publicKey = (pk && pk.toString) ? pk.toString() : (pk && pk.publicKey && pk.publicKey.toString ? pk.publicKey.toString() : pk);
            if (publicKey && (!clientState.wallet || clientState.wallet !== publicKey)){
              clientState.walletProvider = 'solflare';
              const ok = await bindWalletWithPublicKey(publicKey, 'solflare');
              if (ok) showToast('Wallet connected',900);
            }
          });
          window.solflare.on('disconnect', ()=> { clientState.wallet = null; clientState.walletProvider = null; clearBoundWalletFromStorage(); updateUI(); saveClientToStorage(); });
        } catch(e){}
      }

      if (window.backpack && typeof window.backpack.on === 'function'){
        try {
          window.backpack.on('connect', async (pk) => {
            const publicKey = (pk && pk.toString) ? pk.toString() : (pk && pk.publicKey && pk.publicKey.toString ? pk.publicKey.toString() : pk);
            if (publicKey && (!clientState.wallet || clientState.wallet !== publicKey)){
              clientState.walletProvider = 'backpack';
              const ok = await bindWalletWithPublicKey(publicKey, 'backpack');
              if (ok) showToast('Wallet connected',900);
            }
          });
          window.backpack.on('disconnect', ()=> { clientState.wallet = null; clientState.walletProvider = null; clearBoundWalletFromStorage(); updateUI(); saveClientToStorage(); });
        } catch(e){}
      }
    } catch(e){ console.warn('setupInjectedProviderListeners failed', e); }
  }

  async function getMyReferral(){
    try {
      const resp = await api('/player/referral','GET');
      if (resp && resp.refCode){ clientState.referralCode = resp.refCode; clientState.referralsActive = resp.count ?? clientState.referralsActive; saveClientToStorage(); }
      return clientState.referralCode;
    } catch(e){ console.warn('getMyReferral', e); return clientState.referralCode; }
  }

  function showReferralModal(){
    (async ()=>{
      let code = clientState.referralCode || await getMyReferral();
      if (!code) code = 'UNKNOWN';
      const link = `${location.origin}${location.pathname}?ref=${encodeURIComponent(code)}`;
      const body = `<div style="text-align:left">
        <div class="small-muted">Share your referral — both of you can earn rewards</div>
        <div style="margin-top:8px;"><input id="refLinkBox" style="width:100%; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.06)" value="${escapeHtml(link)}" readonly></div>
      </div>`;
      const actions = `<button id="copyRefBtn" class="button"><i class="fa-solid fa-copy"></i> Copy Link</button><button id="shareRefBtn" class="btn-ghost"><i class="fa-solid fa-share-from-square"></i> Share</button><button id="closeRef" class="btn-ghost">Close</button>`;
      showSheet({ title:'Invite Friends', bodyHtml: body + `<div style="margin-top:8px;" class="small-muted">Referrals: ${clientState.referralsActive || 0}</div>`, actionsHtml: actions, onMounted: ()=> {
        const copy = $('copyRefBtn'); const share = $('shareRefBtn'); const close = $('closeRef'); const box = $('refLinkBox');
        if (copy) copy.onclick = async ()=> { try { await navigator.clipboard.writeText(box.value); showToast('Copied!',900); hideSheet(); } catch(e){ alert('Copy failed'); } };
        if (share) share.onclick = async ()=> { try { if (navigator.share) { await navigator.share({ title:'Play Hexon', text:'Join me on Hexon', url: box.value }); hideSheet(); } else { alert('Share not supported — copy link instead'); } } catch(e){} };
        if (close) close.onclick = hideSheet;
      }});
    })();
  }

  async function claimRewards(){
    showSheet({ title:'Claim', bodyHtml:'<div class="small-muted">Claiming rewards…</div>' });
    try {
      const resp = await api('/rewards/claim','POST',{ sessionId: clientState.sessionId });
      if (resp && resp.ok){
        clientState.gpBase = resp.gp ?? clientState.gpBase;
        clientState.userAU = resp.userAU ?? clientState.userAU;
        if (typeof resp.energy === 'number') clientState.energy = Math.max(0, Math.min(100, resp.energy));
        saveClientToStorage();
        updateUI();
        showSheet({ title:'Claim', bodyHtml:'<div class="small-muted">Rewards claimed — closing…</div>' });
        setTimeout(()=>{ hideSheet(); try { const tg = (window.Telegram && window.Telegram.WebApp) ? window.Telegram.WebApp : null; if (tg && typeof tg.close === 'function') tg.close(); } catch(e){} }, 900);
      } else {
        const err = (resp && resp.error) ? resp.error : 'Claim failed — try again later.';
        showSheet({ title:'Claim', bodyHtml:`<div class="small-muted">${escapeHtml(String(err))}</div>` });
        setTimeout(hideSheet,1200);
      }
    } catch(e){ console.warn('claimRewards error', e); showSheet({ title:'Claim', bodyHtml:'<div class="small-muted">Network error — try again later.</div>' }); setTimeout(hideSheet,1200); }
  }

  function isValidSolanaPublicKey(pk){
    if (!pk || typeof pk !== 'string') return false;
    const base58Regex = /^[1-9A-HJ-NP-Za-km-z]+$/;
    if (!base58Regex.test(pk)) return false;
    if (pk.length < 32 || pk.length > 64) return false;
    return true;
  }

  // -----------------------
  // Bottom sheet wiring (unchanged) — keep exactly as you had (omitted for brevity)
  // -----------------------
  (function sheetBootstrap(){
    /* ... copy your existing bottom sheet bootstrap code here unchanged ... */
  })();

  // -----------------------
  // Boot / init (modified to start WS)
  // -----------------------
  document.addEventListener('DOMContentLoaded', async ()=>{
    try {
      initTelegram();
      readWalletReturn();
      const ref = getRefFromURL();
      if (ref) savePendingReferral(ref); else loadPendingReferral();

      // wire page buttons (unchanged wiring)
      try{ const wa = $('watchAdBtn'); if (wa) wa.addEventListener('click', showAdAndVerify); } catch(e){}
      try{ const os = $('openStore'); if (os) os.addEventListener('click', ()=> window.location.href = 'shop.html'); } catch(e){}
      try{ const bw = $('bindWalletBtn'); if (bw) bw.addEventListener('click', (ev)=> { ev.preventDefault(); ev.stopPropagation(); if (typeof window._hexon_openWalletSheet === 'function') { window._hexon_openWalletSheet(); } else { showSheet({ title: 'Connect Wallet' }); } }); } catch(e){}
      try{ const sr = $('showRefBtn'); if (sr) sr.addEventListener('click', showReferralModal); } catch(e){}
      try{ const va = $('viewAlloc'); if (va) va.addEventListener('click', ()=> showSheet({ title: 'Allocation', bodyHtml: '<div class="small-muted">Allocation preview</div>' })); } catch(e){}
      try{ const cr = $('claimRewardBtn'); if (cr) cr.addEventListener('click', claimRewards); } catch(e){}

      // Restore saved client & game if present (persistence)
      const savedClient = loadClientFromStorage();
      if (savedClient){
        const keepSession = clientState.sessionId;
        Object.assign(clientState, savedClient);
        clientState.sessionId = keepSession || clientState.sessionId;
      }

      const savedGame = loadGameFromStorage();
      if (savedGame){
        try {
          if (Array.isArray(savedGame.grid) && savedGame.grid.length === GRID_ROWS){
            gameState.grid = savedGame.grid;
            gameState.activePiece = savedGame.activePiece;
            gameState.nextPiece = savedGame.nextPiece;
            gameState.score = savedGame.score || 0;
            gameState.level = savedGame.level || 1;
            gameState.lines = savedGame.lines || 0;
            gameState.dropInterval = savedGame.dropInterval || INITIAL_DROP_MS;
            gameState.isPlaying = savedGame.isPlaying !== undefined ? savedGame.isPlaying : true;
            gameState.combo = savedGame.combo || 0;
            gameState.lastSavedAt = savedGame.lastSavedAt || Date.now();
            gameState.lastTickAt = savedGame.lastTickAt || Date.now();
          } else {
            initGrid();
            clearSavedGame();
          }
        } catch(e){
          initGrid();
          clearSavedGame();
        }
      } else {
        if (!gameState.grid) initGrid();
        if (!gameState.activePiece) spawnPiece();
      }

      // initial client init with server (best-effort)
      try {
        const init = await api('/client/init','POST',{ sessionId: clientState.sessionId, referral: clientState.pendingReferral || null, username: clientState.username, telegramId: clientState.telegramId });
        if (init){
          if (init.sessionId && init.sessionId !== clientState.sessionId){ clientState.sessionId = init.sessionId; saveSessionToStorage(clientState.sessionId); }
          clientState.userId = init.userId ?? clientState.userId;
          clientState.gpBase = init.gp ?? clientState.gpBase;
          clientState.miners = init.miners ?? clientState.miners;
          clientState.userAU = init.userAU ?? clientState.userAU;
          clientState.totalAU = init.totalAU ?? clientState.totalAU;
          clientState.referralsActive = init.referralsActive ?? clientState.referralsActive;
          clientState.referralCode = init.referralCode ?? clientState.referralCode;
          if (!clientState.username && init.username) clientState.username = init.username;
          if (init.referralAccepted) clearPendingReferral();
          if (init.wallet) { clientState.wallet = init.wallet; clientState.walletProvider = init.walletProvider || clientState.walletProvider; saveBoundWalletToStorage(clientState.wallet, clientState.walletProvider); }
          if (typeof init.energy === 'number') clientState.energy = Math.max(0, Math.min(100, init.energy));
          saveClientToStorage();
        }
      } catch(e){ console.warn('client init failed', e); }

      // compute scale & start phaser (unchanged)
      const parentEl = $('phaserCanvas') || document.body;
      const rect = parentEl.getBoundingClientRect();
      const availW = Math.max(320, rect.width || Math.min(window.innerWidth * 0.98, 900));
      const availH = Math.max(260, rect.height || Math.min(window.innerHeight * 0.5, 900));
      const desiredW = GRID_COLS * (BASE_CELL + BASE_GAP) + 40;
      const desiredH = GRID_ROWS * (BASE_CELL + BASE_GAP) + 40;
      const scale = Math.min(1, Math.min(availW / desiredW, availH / desiredH));
      CELL = Math.max(8, Math.floor(BASE_CELL * scale));
      GAP = Math.max(1, Math.floor(BASE_GAP * scale));
      const canvasWidth = GRID_COLS * (CELL + GAP) + 40;
      const canvasHeight = GRID_ROWS * (CELL + GAP) + 40;
      if (parentEl && parentEl.style){ parentEl.style.minWidth = Math.min(canvasWidth, Math.max(260, canvasWidth)) + 'px'; parentEl.style.minHeight = Math.min(canvasHeight, Math.max(260, canvasHeight)) + 'px'; parentEl.style.maxHeight = '56vh'; }

      phaserGame = new Phaser.Game({ type: Phaser.AUTO, parent: 'phaserCanvas', width: canvasWidth, height: canvasHeight, backgroundColor: '#061426', scene: [ BootScene, GameScene ], render: { pixelArt: false, antialias: true } });

      setupInjectedProviderListeners();
      loadAdsGram();

      // start WS and flush loop
      ensureWebsocket();

      updateUI();
      renderMinersList();
      refreshLeaderboard();
      setInterval(()=>{ refreshLeaderboard(); updateUI(); }, 15000);
      setInterval(()=>{ gameState.lastTickAt = Date.now(); saveGameToStorage(); saveClientToStorage(); }, 3000);

    } catch(err){ console.error('Hexon boot failure:', err); }
  });

  // -----------------------
  // AdsGram + ad flow (kept + realtime event)
  // -----------------------
  let AdsGramLoaded = false, AdController = null;
  function loadAdsGram(){
    try {
      if (window.Adsgram && !AdController){ try{ AdController = window.Adsgram.init({ blockId: ADSGRAM_BLOCK_ID }); AdsGramLoaded = true; return; } catch(e){ console.warn('adsgram init existing', e); } }
      if (AdsGramLoaded) return;
      const s = document.createElement('script'); s.src = ADSGRAM_SRC; s.async = true;
      s.onload = ()=>{ try{ if (window.Adsgram && typeof window.Adsgram.init === 'function'){ AdController = window.Adsgram.init({ blockId: ADSGRAM_BLOCK_ID }); AdsGramLoaded = true; } }catch(e){ console.warn('AdsGram init error', e); } };
      s.onerror = ()=>{ console.warn('Failed to load AdsGram SDK'); };
      document.head.appendChild(s);
    } catch(e){ console.warn('loadAdsGram', e); }
  }

  async function showAdAndVerify(){
    if ((clientState.adsToday||0) >= MAX_ADS_PER_DAY){ showSheet({ title:'Ad', bodyHtml:'<div class="small-muted">Daily ad limit reached.</div>' }); return; }
    if ((clientState.adsThisSitting||0) >= MAX_ADS_PER_SITTING){ showSheet({ title:'Ad', bodyHtml:'<div class="small-muted">Sitting ad limit reached.</div>' }); return; }
    showSheet({ title:'Sponsored Transmission', bodyHtml:'<div class="small-muted">Opening sponsored transmission…</div>' });
    try {
      let provider='Fallback', payload={ adSessionId: generateUUID() };
      if (AdsGramLoaded && AdController && typeof AdController.show === 'function'){
        provider='AdsGram';
        try { const result = await AdController.show(); payload={ result }; } catch(err){ showToast('Ad failed / skipped — no reward',1200); hideSheet(); return; }
      } else {
        await new Promise(res=>setTimeout(res,1800));
      }
      const resp = await api('/ad/verify','POST',{ sessionId: clientState.sessionId, provider, payload });
      hideSheet();
      if (resp && resp.grantedPercent){
        clientState.energy = Math.min(100, clientState.energy + resp.grantedPercent);
        clientState.adsThisSitting = (clientState.adsThisSitting||0) + 1;
        clientState.adsToday = (clientState.adsToday||0) + 1;
        logAction('ad_watched',{ provider, granted: resp.grantedPercent });
        // realtime event for ad
        realtimeEvent('ad_verify', { provider, granted: resp.grantedPercent }, { priority:true });
        saveClientToStorage();
        updateUI();
        showToast(`Energy credited +${resp.grantedPercent}%`,1200);
      } else {
        const msg = (resp && resp.error) ? resp.error : 'Ad verification failed';
        showSheet({ title:'Ad', bodyHtml:`<div class="small-muted">${escapeHtml(msg)}</div>` });
      }
    } catch(e){ hideSheet(); console.warn('showAdAndVerify error', e); showToast('Ad error — try later',1200); }
  }

  // -----------------------
  // small UI sheet helpers (unchanged)
  // -----------------------
  function getSheetElements(){ return { overlay: $('overlay'), sheetBody: $('sheetBody'), sheetTitle: document.querySelector('.sheet-title'), sheetActions: $('sheetActions'), showToast: window._hexon_showToast || ((m,t)=> { const el = $('toast'); if(!el) return; el.textContent = m; el.style.display='block'; setTimeout(()=> el.style.display='none', t||2000); }) }; }
  function showSheet({ title='Info', bodyHtml='', actionsHtml='', onMounted=null } = {}){
    const { overlay, sheetBody, sheetTitle, sheetActions } = getSheetElements();
    if (!overlay || !sheetBody || !sheetTitle || !sheetActions){ console.warn('Sheet elements missing'); const { showToast } = getSheetElements(); showToast('UI unavailable', 1200); return; }
    sheetTitle.textContent = title;
    sheetBody.innerHTML = bodyHtml;
    sheetActions.innerHTML = actionsHtml;
    overlay.classList.add('show');
    overlay.setAttribute('aria-hidden','false');
    try{ sheetBody.focus(); }catch(e){}
    if (typeof onMounted === 'function'){ setTimeout(()=> { try{ onMounted(); } catch(e){ console.warn('sheet onMounted error', e); } }, 50); }
  }
  function hideSheet(){ const { overlay } = getSheetElements(); if (!overlay) return; overlay.classList.remove('show'); overlay.setAttribute('aria-hidden','true'); }

  // -----------------------
  // Misc helpers exported
  // -----------------------
  window._hexon_showToast = (m,t)=> { const el = $('toast'); if(!el) return; el.textContent = m; el.style.display='block'; setTimeout(()=> el.style.display='none', t||2000); };

  </script>
</body>
</html>
