<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Hexon — Miner Shop (Telegram Mini App)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;800&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <!-- AdsGram SDK (required for Rewarded / Interstitial) -->
  <script src="https://sad.adsgram.ai/js/sad.min.js" defer></script>

  <style>
    /* (kept most of your visual design, but tightened spacing for Telegram mini-app) */
    :root{
      --bg: linear-gradient(180deg,#030616 0%, #071027 45%, #041123 100%);
      --accent-from: #6EE7B7; --accent-to:#60A5FA;
      --muted:#9fcbdc; --card-radius:12px; --pad:12px;
    }
    html,body{ height:100%; margin:0; font-family:'Orbitron',sans-serif; background:var(--bg); color:#DFF6FF; -webkit-font-smoothing:antialiased; padding:12px; box-sizing:border-box; }
    .app{ max-width:980px; margin:0 auto; display:flex; gap:12px; align-items:flex-start; }
    .col{ background: rgba(255,255,255,0.03); border-radius:var(--card-radius); padding:14px; box-shadow:0 8px 30px rgba(0,0,0,0.5); }
    .col--main{ flex:1; }
    .col--side{ width:320px; min-width:240px; display:flex; flex-direction:column; gap:10px; }
    header{ display:flex; gap:10px; align-items:center; }
    .logo{ width:44px; height:44px; border-radius:10px; display:flex; align-items:center; justify-content:center; font-weight:900; font-size:18px; color:#021125; background:linear-gradient(90deg,var(--accent-from),var(--accent-to)); }
    nav{ margin-left:auto; display:flex; gap:8px; align-items:center; }
    nav button{ background:transparent; border:1px solid rgba(255,255,255,0.06); color:inherit; padding:8px 10px; border-radius:10px; font-weight:700; }
    h1{ font-size:18px; margin:0; }
    .muted{ color:var(--muted); font-size:13px; }

    .grid{ display:grid; grid-template-columns: repeat(auto-fill,minmax(200px,1fr)); gap:10px; margin-top:12px; }
    .item{ border-radius:10px; padding:10px; display:flex; flex-direction:column; gap:8px; min-height:210px; }
    .media{ width:100%; aspect-ratio:16/9; border-radius:8px; overflow:hidden; background:#041123; display:flex; align-items:center; justify-content:center; }
    .name{ font-weight:900; }
    .desc{ color:var(--muted); font-size:13px; min-height:36px; }

    .meta-row{ display:flex; justify-content:space-between; align-items:center; gap:8px; }
    .au-badge{ background:linear-gradient(90deg,#FFD86B,#FF9E6B); color:#021125; padding:6px 10px; border-radius:8px; font-weight:800; }

    .actions{ display:flex; gap:8px; margin-top:auto; }
    .btn{ padding:8px 10px; border-radius:10px; font-weight:900; cursor:pointer; border:0; }
    .btn--primary{ background:linear-gradient(90deg,var(--accent-from),var(--accent-to)); color:#021125; }
    .btn--ghost{ background:transparent; border:1px solid rgba(255,255,255,0.06); color:#9EEAFF; }

    .miners-list{ display:flex; flex-direction:column; gap:10px; margin-top:8px; }
    .miner-card{ display:flex; gap:8px; align-items:center; padding:8px; border-radius:10px; }

    .toast{ position: fixed; left: 50%; transform: translateX(-50%); bottom: 14px; background: rgba(3,10,18,0.95); color:#E6F7FF; padding:8px 12px; border-radius:10px; display:none; z-index:9999; }
    .lightbox{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.85); z-index:99999; padding:18px; }
    .lightbox.show{ display:flex; }
    @media (max-width:980px){ .app{ flex-direction:column; padding:8px; } .col--side{ width:100%; } }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Hexon Miner Shop">
    <div class="col col--main">
      <header>
        <div class="logo">HX</div>
        <div>
          <h1>Hexon Miner Shop</h1>
          <div class="muted">Web3-style shop — buy miners & upgrade with reward ads</div>
        </div>
        <nav>
          <button id="refreshBtn" title="Refresh"><i class="fa-solid fa-arrows-rotate"></i></button>
          <div style="min-width:86px;text-align:center;background:linear-gradient(90deg,var(--accent-from),var(--accent-to));color:#021125;padding:8px;border-radius:10px;font-weight:900" id="balanceBadge">— GP</div>
        </nav>
      </header>

      <section aria-labelledby="shopTitle" style="margin-top:12px">
        <h2 id="shopTitle">Available Miners & Items</h2>
        <p class="muted">Buy miners to increase your AU (hash units). Upgrades are rewarded via real AdsGram reward ads.</p>
        <div id="itemsContainer" class="grid" aria-live="polite">
          <div class="muted">Loading items…</div>
        </div>
      </section>
    </div>

    <aside class="col col--side" aria-labelledby="sidebarTitle">
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div><h3 id="sidebarTitle" style="margin:0">Your Miners</h3><div class="muted">Purchased miners & upgrades</div></div>
        <div style="text-align:right"><div class="muted small">AU total</div><div id="totalAu" class="au-badge" style="margin-top:6px">—</div></div>
      </div>

      <div id="minersList" class="miners-list" aria-live="polite">
        <div class="muted small">No miners yet — buy one from the shop.</div>
      </div>

      <div style="display:flex;gap:8px;margin-top:10px">
        <button id="claimReward" class="btn btn--primary">Claim daily</button>
        <button id="bindWallet" class="btn btn--ghost">Bind wallet</button>
      </div>

      <div style="margin-top:10px;font-size:12px;color:var(--muted)">Ads provider: <strong id="adsProviderLabel">AdsGram</strong> (blockId: <code id="adsBlockId">22918</code>)</div>
    </aside>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>
  <div id="lightbox" class="lightbox" role="dialog" aria-modal="true" tabindex="-1" onclick="hideLightbox(event)"><img id="lightboxImg" alt="Preview" style="max-width:100%;max-height:95vh;border-radius:8px"/></div>

<script>
/* -------------------------
   Config + state
-------------------------*/
const ADSGRAM_BLOCK_ID = '22918'; // provided block id
const API_BASE = 'https://bold-inherited-jamie-griffin.trycloudflare.com'; // update to your backend
let AdController = null; // AdsGram controller instance

const clientState = {
  sessionId: localStorage.getItem('hexon_session') || generateUUID(),
  username: localStorage.getItem('hexon_username') || null,
  telegramId: null,
  gp: null,
  miners: loadLocalMiners()
};

localStorage.setItem('hexon_session', clientState.sessionId);

/* -------------------------
   Helpers
-------------------------*/
function $(id){ return document.getElementById(id); }
function generateUUID(){ try { if (window.crypto && crypto.randomUUID) return crypto.randomUUID(); } catch(e){} return 'sess-'+Math.floor(Math.random()*1e12).toString(36); }
function showToast(msg, ms=3500){ const t=$('toast'); t.textContent=msg; t.style.display='block'; clearTimeout(t._hide); t._hide=setTimeout(()=>t.style.display='none', ms); }
function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* -------------------------
   Simple API helper
-------------------------*/
async function api(path, method='GET', body=null, optsExtra={}) {
  try {
    const base = API_BASE ? API_BASE.replace(/\/$/,'') : window.location.origin;
    const url = path.startsWith('http') ? path : (base + path);
    const headers = Object.assign({}, optsExtra.headers || {});
    if (!optsExtra.skipJsonHeader && method.toUpperCase() !== 'GET') headers['Content-Type'] = headers['Content-Type'] || 'application/json';
    if (clientState.sessionId) headers['X-Session-Id'] = clientState.sessionId;
    if (clientState.username) headers['X-User-Handle'] = clientState.username;

    const fetchOpts = { method, headers, ...optsExtra };
    if (body !== null && typeof body !== 'undefined'){
      if (fetchOpts.headers['Content-Type'] && fetchOpts.headers['Content-Type'].includes('application/json') && typeof body === 'object'){
        body.sessionId = body.sessionId || clientState.sessionId;
        body.username = body.username || clientState.username || null;
        fetchOpts.body = JSON.stringify(body);
      } else fetchOpts.body = body;
    }

    const res = await fetch(url, fetchOpts);
    const txt = await res.text();
    try { return txt ? JSON.parse(txt) : { raw: '' , _httpStatus: res.status }; } catch(e){ return { raw: txt, _httpStatus: res.status }; }
  } catch(err){ console.warn('api error', err); return null; }
}

/* -------------------------
   Telegram integration (if available)
   - expand to full screen, sync theme, and use haptics and MainButton where useful
-------------------------*/
let tg = null;
function initTelegram(){
  try {
    if (window.Telegram && window.Telegram.WebApp){
      tg = window.Telegram.WebApp;
      try { if (typeof tg.ready === 'function') tg.ready(); } catch(e){}
      if (tg.initDataUnsafe && tg.initDataUnsafe.user) {
        clientState.telegramId = tg.initDataUnsafe.user.id;
        clientState.username = clientState.username || (tg.initDataUnsafe.user.username || `${tg.initDataUnsafe.user.first_name||''}`.trim());
        if (clientState.username) localStorage.setItem('hexon_username', clientState.username);
      }
      try { tg.expand(); } catch(e){}
    }
  } catch(e){ console.warn('initTelegram', e); tg = null; }
}

/* -------------------------
   AdsGram SDK init
   - per AdsGram docs: include SDK and call Adsgram.init({ blockId })
   - then use AdController.show() in click handlers. (Docs: include script, call init, then show()). 
   - We init when the SDK is available.
   (See AdsGram docs for details.)
-------------------------*/
function initAdsGram() {
  try {
    if (!window.Adsgram) {
      // SDK may not yet be parsed - wait briefly
      setTimeout(initAdsGram, 250);
      return;
    }
    // init returns controller used to show ads
    AdController = window.Adsgram.init({ blockId: ADSGRAM_BLOCK_ID });
    console.debug('AdsGram initialized', AdController);
  } catch(err){
    console.warn('initAdsGram error', err);
  }
}

/* -------------------------
   Local miners persistence
-------------------------*/
function loadLocalMiners(){
  try { return JSON.parse(localStorage.getItem('hexon_miners_v1')||'[]'); } catch(e){ return []; }
}
function saveLocalMiners(list){ try { localStorage.setItem('hexon_miners_v1', JSON.stringify(list||[])); } catch(e){} }

/* -------------------------
   UI renderers & shop loader (keeps your original endpoint discovery)
-------------------------*/
const DISPLAY_ENDPOINT_CANDIDATES = ['/shop/items','/miners/display','/miners','/shop/miners','/api/shop/items','/api/miners'];
let discoveredEndpoint = null;

async function discoverDisplayEndpoint(){
  for (const p of DISPLAY_ENDPOINT_CANDIDATES){
    try {
      const resp = await api(p, 'GET');
      if (!resp) continue;
      if (Array.isArray(resp)) return p;
      if (resp && typeof resp === 'object'){
        if (Array.isArray(resp.items) || Array.isArray(resp.data)) return p;
        for (const k of Object.keys(resp)){ if (Array.isArray(resp[k])) return p; }
      }
    } catch(e){}
  }
  return null;
}

function updateBalanceUI(){ const badge = $('balanceBadge'); badge.textContent = (clientState.gp===null||typeof clientState.gp==='undefined')? '— GP' : `${Number(clientState.gp).toLocaleString()} GP`; }
function renderMinersList(){
  const list = $('minersList');
  const miners = clientState.miners || [];
  if (!miners || miners.length===0){ list.innerHTML = '<div class="muted small">No miners yet — buy one from the shop.</div>'; $('totalAu').textContent='0'; return; }
  list.innerHTML = '';
  let totalAu = 0;
  for (const m of miners){
    totalAu += Number(m.au||0);
    const el = document.createElement('div');
    el.className = 'miner-card';
    el.innerHTML = `
      <div style="width:48px;height:48px;border-radius:8px;background:linear-gradient(135deg,#9BE7FF,#7EE7FF);display:flex;align-items:center;justify-content:center;color:#021125;font-weight:900">${escapeHtml(String((m.name||m.sku||'M').charAt(0)))}</div>
      <div style="flex:1;min-width:0">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="min-width:0">
            <div style="font-weight:900">${escapeHtml(m.name||m.sku||'Unnamed Miner')}</div>
            <div class="muted small">ID: <code style="color:var(--muted)">${escapeHtml(String(m.item_id ?? m.id ?? '—'))}</code></div>
          </div>
          <div style="text-align:right">
            <div class="muted small">AU</div>
            <div style="margin-top:6px;background:linear-gradient(90deg,#FFD86B,#FF9E6B);color:#021125;padding:6px 8px;border-radius:8px;font-weight:800">${Number(m.au||0)}</div>
          </div>
        </div>
        <div style="margin-top:8px;display:flex;gap:8px">
          <button class="btn btn--primary btn-upgrade small">Upgrade (watch ad)</button>
          <button class="btn btn--ghost btn-view small">View</button>
        </div>
      </div>
    `;
    const upgradeBtn = el.querySelector('.btn-upgrade');
    const viewBtn = el.querySelector('.btn-view');
    upgradeBtn.dataset.minerId = String(m.id ?? m.item_id ?? m.sku ?? m.name);
    upgradeBtn.addEventListener('click', ()=> handleUpgradeClick(upgradeBtn.dataset.minerId, m, upgradeBtn));
    viewBtn.addEventListener('click', ()=> { if (m.image_url) showLightbox(m.image_url); else showToast('No preview image.'); });
    list.appendChild(el);
  }
  $('totalAu').textContent = totalAu;
  saveLocalMiners(miners);
}

async function loadClientState(){
  const resp = await api('/client/init','POST',{ sessionId: clientState.sessionId }).catch(()=>null);
  if (resp && resp.ok){
    clientState.sessionId = resp.sessionId || clientState.sessionId;
    clientState.username = resp.username || clientState.username;
    clientState.gp = (typeof resp.gp !== 'undefined') ? Number(resp.gp) : clientState.gp;
    if (resp.miners && Array.isArray(resp.miners) && resp.miners.length) { clientState.miners = resp.miners.slice(); saveLocalMiners(clientState.miners); }
    else { clientState.miners = clientState.miners || loadLocalMiners(); }
    localStorage.setItem('hexon_session', clientState.sessionId);
    if (clientState.username) localStorage.setItem('hexon_username', clientState.username);
  }
  updateBalanceUI();
  renderMinersList();
}

async function loadShop(){
  const container = $('itemsContainer');
  container.innerHTML = '<div class="muted">Loading items…</div>';
  await loadClientState();
  if (!discoveredEndpoint) discoveredEndpoint = await discoverDisplayEndpoint();
  if (!discoveredEndpoint){ container.innerHTML = '<div class="muted">Shop unavailable (no display endpoint found)</div>'; return; }
  const itemsResp = await api(discoveredEndpoint,'GET').catch(()=>null);
  if (!itemsResp){ container.innerHTML = '<div class="muted">Shop unavailable (failed to fetch items)</div>'; return; }
  let items = [];
  if (Array.isArray(itemsResp)) items = itemsResp;
  else if (Array.isArray(itemsResp.items)) items = itemsResp.items;
  else if (Array.isArray(itemsResp.data)) items = itemsResp.data;
  else { for (const k of Object.keys(itemsResp)) if (Array.isArray(itemsResp[k])) { items = itemsResp[k]; break; } }

  if (!items || items.length===0){ container.innerHTML = '<div class="muted">No items available</div>'; return; }
  container.innerHTML = '';
  for (const rawItem of items){
    const item = Object.assign({}, rawItem);
    const chosenToken = item.id ?? item.item_id ?? item.sku ?? item.code ?? item._id;
    if (!chosenToken) continue;
    const chosenIdStr = String(chosenToken);
    const name = String(item.name || item.title || 'Unnamed Miner');
    const desc = String(item.description || item.desc || '');
    const price = Number(item.price_gp ?? item.priceGP ?? item.price ?? 0);
    const imageUrl = String(item.image_url || item.image || item.imageUrl || '') || null;

    const card = document.createElement('div');
    card.className = 'item';
    card.innerHTML = `
      <div class="media" role="button" tabindex="0" aria-label="Preview ${escapeHtml(name)}">
        ${ imageUrl ? `<img loading="lazy" src="${escapeHtml(imageUrl)}" alt="${escapeHtml(name)}" style="width:100%;height:100%;object-fit:cover">` : `<div class="muted small" style="padding:12px">No image</div>` }
      </div>
      <div><div class="name">${escapeHtml(name)}</div><div class="desc">${escapeHtml(desc)}</div></div>
      <div class="meta-row"><div class="price">${price.toLocaleString()} GP</div><div class="au-badge">${Number(item.au||0)} AU</div></div>
      <div class="actions">
        <button class="btn btn--primary buyBtn"><i class="fa-solid fa-cart-plus"></i> Buy</button>
        <button class="btn btn--ghost viewBtn">${ imageUrl ? '<i class="fa-solid fa-eye"></i> View' : '<i class="fa-solid fa-image"></i> No preview'}</button>
      </div>
    `;
    container.appendChild(card);

    const buyBtn = card.querySelector('.buyBtn');
    const viewBtn = card.querySelector('.viewBtn');
    const mediaEl = card.querySelector('.media');
    buyBtn.dataset.itemId = chosenIdStr;
    buyBtn.dataset.price = String(price);
    buyBtn.dataset.name = String(name);
    buyBtn.dataset.au = String(item.au||0);
    if (imageUrl) buyBtn.dataset.image = imageUrl;

    function refreshBuyState(){
      if (clientState.gp === null || typeof clientState.gp === 'undefined'){ buyBtn.disabled=false; buyBtn.innerHTML = '<i class="fa-solid fa-cart-plus"></i> Buy'; return; }
      if (Number(clientState.gp) < Number(price)){ buyBtn.disabled=true; buyBtn.title='Insufficient GP'; buyBtn.innerHTML = `<i class="fa-solid fa-ban"></i> Need ${(Number(price)-Number(clientState.gp)).toLocaleString()} GP`; }
      else { buyBtn.disabled=false; buyBtn.title=''; buyBtn.innerHTML = '<i class="fa-solid fa-cart-plus"></i> Buy'; }
    }
    refreshBuyState();

    const openPreview = ()=> { if (!imageUrl) return; showLightbox(imageUrl); };
    if (viewBtn && imageUrl) viewBtn.addEventListener('click', openPreview);
    if (mediaEl && imageUrl){ mediaEl.addEventListener('click', openPreview); mediaEl.addEventListener('keydown',(e)=>{ if (e.key==='Enter' || e.key===' ') openPreview(); }); }

    buyBtn.addEventListener('click', async ()=>{
      const idStr = buyBtn.dataset.itemId || '';
      if (!idStr){ showToast('Invalid item id — cannot buy.'); return; }
      const nameLabel = buyBtn.dataset.name || 'item';
      const priceNum = Number(buyBtn.dataset.price||0);
      if (!confirm(`Buy "${nameLabel}" for ${priceNum.toLocaleString()} GP?`)) return;
      buyBtn.disabled = true; const origHtml = buyBtn.innerHTML; buyBtn.innerHTML = 'Processing…';
      const payload = { sessionId: clientState.sessionId, username: clientState.username || null, itemId: idStr, id: idStr };
      let resp = null;
      const buyPaths = ['/shop/buy','/buy','/miners/buy','/api/shop/buy'];
      for (const p of buyPaths){
        try { resp = await api(p,'POST',payload); } catch(e){ resp=null; }
        if (resp && (typeof resp.ok!=='undefined' || resp._httpStatus)) break;
      }
      if (!resp){ showToast('Network/server error while buying.'); buyBtn.disabled=false; buyBtn.innerHTML=origHtml; return; }
      if (resp.ok){
        if (typeof resp.gp !== 'undefined') clientState.gp = Number(resp.gp);
        // get miner object or construct one
        let newMiner = (resp.purchased && resp.purchased.miner) ? resp.purchased.miner : {
          id: resp.purchased && resp.purchased.itemId ? resp.purchased.itemId : idStr,
          item_id: resp.purchased && resp.purchased.itemId ? resp.purchased.itemId : idStr,
          name: nameLabel, au: Number(buyBtn.dataset.au||0), image_url: buyBtn.dataset.image||null, created_at: (new Date()).toISOString()
        };
        // add to local cache
        const miners = clientState.miners || [];
        const key = String(newMiner.id ?? newMiner.item_id ?? newMiner._id ?? newMiner.sku ?? newMiner.name);
        const exists = miners.find(x => String(x.id ?? x.item_id ?? x._id ?? x.sku ?? x.name) === key);
        if (!exists) miners.push(newMiner);
        clientState.miners = miners; saveLocalMiners(miners); renderMinersList();
        showToast('Purchase successful');
        await loadClientState(); await loadShop();
        return;
      } else {
        let errMsg = 'Purchase failed';
        if (typeof resp.error !== 'undefined') errMsg = String(resp.error);
        else if (resp && resp.raw) errMsg = String(resp.raw);
        showToast(errMsg); buyBtn.disabled=false; buyBtn.innerHTML=origHtml; return;
      }
    });
  }
  updateBalanceUI();
}

/* -------------------------
   Upgrade flow using AdsGram (real reward ad)
   - Uses AdController.show() from AdsGram SDK
   - On success (result.done === true) we POST to /ad/verify to let our backend verify + grant reward.
   - If backend verifies, we persist upgrade server-side; if not available we apply optimistic local update but still send verify request.
   - This removes any client-side "ad simulation".
-------------------------*/
async function handleUpgradeClick(minerId, minerObj, btnEl){
  if (!AdController){ showToast('Ads are not ready yet.'); initAdsGram(); return; }

  // Optional: simple per-miner cooldown logic (keeps your previous approach)
  const adState = (function(){ try { return JSON.parse(localStorage.getItem('hexon_adstate_v1')||'{}') } catch(e){ return {}; } })()[minerId] || { count:0, cooldownStart:null };
  const MAX_ADS_PER_CYCLE = 3;
  const COOLDOWN_MS = 30*60*1000;
  if (adState.cooldownStart && (Date.now() - adState.cooldownStart) < COOLDOWN_MS){
    const mins = Math.ceil((COOLDOWN_MS - (Date.now() - adState.cooldownStart))/60000);
    showToast(`Cooldown active — try in ~${mins} minute(s).`);
    return;
  }
  if (adState.count >= MAX_ADS_PER_CYCLE){ adState.cooldownStart = Date.now(); localStorage.setItem('hexon_adstate_v1', JSON.stringify(Object.assign({}, JSON.parse(localStorage.getItem('hexon_adstate_v1')||'{}'), { [minerId]: adState } ))); showToast('Cooldown started.'); return; }

  if (!confirm('Watch a short rewarded ad to upgrade this miner?')) return;

  // Show ad using AdsGram SDK (see AdsGram docs: AdController.show())
  btnEl.disabled = true;
  const originalText = btnEl.innerHTML;
  btnEl.innerHTML = 'Opening ad…';

  try {
    const result = await AdController.show(); // resolves when ad finished/closed (result.done true if watched to end)
    // result fields: { done: boolean, description: string, state: 'load'|'render'|'playing'|'destroy', error: boolean }
    // (Docs describe show() promise & its result semantics.)
    if (!result || !result.done) {
      showToast('Ad was not completed. No reward given.');
      btnEl.disabled = false; btnEl.innerHTML = originalText;
      return;
    }

    // Send show result to backend for server-side verification & reward granting
    const verifyPayload = {
      sessionId: clientState.sessionId,
      provider: 'adsgram',
      payload: {
        blockId: ADSGRAM_BLOCK_ID,
        minerId: minerId,
        showResult: result,
        clientTs: (new Date()).toISOString()
      }
    };
    btnEl.innerHTML = 'Verifying…';
    const vresp = await api('/ad/verify','POST', verifyPayload).catch(()=>null);

    // Server should respond with ok and details (for example: grantedPercent or deltaAU)
    if (vresp && vresp.ok){
      // If server returned updated miner object, replace it
      if (vresp.miner){
        clientState.miners = (clientState.miners || []).map(m => {
          const key = String(m.id ?? m.item_id ?? m._id ?? m.sku ?? m.name);
          if (key === String(minerId)) return vresp.miner;
          return m;
        });
        saveLocalMiners(clientState.miners);
        renderMinersList();
      } else if (typeof vresp.grantedPercent !== 'undefined' || typeof vresp.delta !== 'undefined'){
        const grantedPercent = Number(vresp.grantedPercent || 0) || 10;
        const currentAu = Number(minerObj.au || 0);
        const delta = typeof vresp.delta !== 'undefined' ? Number(vresp.delta) : Math.max(1, Math.floor(currentAu * (grantedPercent/100)));
        applyLocalMinerAUUpdate(minerId, currentAu + delta);
        renderMinersList();
      }
      showToast('Upgrade applied!');
      // increment ad state and persist cooldown if needed
      adState.count = (adState.count||0) + 1;
      if (adState.count >= MAX_ADS_PER_CYCLE) adState.cooldownStart = Date.now();
      const fullMap = (()=>{ try { return JSON.parse(localStorage.getItem('hexon_adstate_v1')||'{}'); } catch(e){ return {}; } })();
      fullMap[minerId] = adState; localStorage.setItem('hexon_adstate_v1', JSON.stringify(fullMap));
    } else {
      // If server verification failed or missing, do optimistic local update and still show message
      const fallbackPercent = 10;
      const currentAu = Number(minerObj.au || 0);
      const delta = Math.max(1, Math.floor(currentAu * (fallbackPercent/100)));
      applyLocalMinerAUUpdate(minerId, currentAu + delta);
      renderMinersList();
      showToast('Upgrade applied locally (server verification missing).');
      // still increment local ad count/cooldown as above
      adState.count = (adState.count||0) + 1;
      if (adState.count >= MAX_ADS_PER_CYCLE) adState.cooldownStart = Date.now();
      const fullMap = (()=>{ try { return JSON.parse(localStorage.getItem('hexon_adstate_v1')||'{}'); } catch(e){ return {}; } })();
      fullMap[minerId] = adState; localStorage.setItem('hexon_adstate_v1', JSON.stringify(fullMap));
    }
  } catch(err){
    console.warn('AdController.show() error', err);
    showToast('Ad failed to play.');
  } finally {
    btnEl.disabled = false;
    btnEl.innerHTML = originalText;
  }
}

/* update local miner AU */
function applyLocalMinerAUUpdate(minerId, newAu){
  const miners = clientState.miners || [];
  for (let i=0;i<miners.length;i++){
    const m = miners[i];
    const key = String(m.id ?? m.item_id ?? m._id ?? m.sku ?? m.name);
    if (key === String(minerId)){
      miners[i].au = Number(newAu);
      break;
    }
  }
  clientState.miners = miners;
  saveLocalMiners(miners);
}

/* lightbox */
function showLightbox(url){ const lb=$('lightbox'), img=$('lightboxImg'); img.src=url; lb.classList.add('show'); lb.focus(); }
function hideLightbox(ev){ if (ev && ev.target && ev.target.id === 'lightboxImg') return; const lb=$('lightbox'); lb.classList.remove('show'); $('lightboxImg').src=''; }
document.addEventListener('keydown', (e)=>{ if (e.key==='Escape') hideLightbox(); });

/* wiring */
$('refreshBtn').addEventListener('click', ()=> { loadClientState().then(()=>loadShop()); });
$('claimReward').addEventListener('click', async ()=> {
  const resp = await api('/rewards/claim','POST',{}).catch(()=>null);
  if (resp && resp.ok){ clientState.gp = Number(resp.gp||clientState.gp); updateBalanceUI(); showToast('Reward claimed!'); }
  else showToast('Claim failed.');
});
$('bindWallet').addEventListener('click', ()=> showToast('Wallet bind flow — implement wallet popup to POST /wallet/bind'));

document.addEventListener('DOMContentLoaded', ()=>{
  initTelegram();
  initAdsGram(); // initialize AdsGram SDK (will wait if SDK not parsed yet)
  renderMinersList();
  loadClientState().then(()=> loadShop());
});
</script>
</body>
</html>
