<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Hexon — Miner Shop</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;800&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <style>
    :root{
      --bg:#071027;
      --card-bg: rgba(255,255,255,0.03);
      --muted:#9fcbdc;
      --accent-from:#3b82f6;
      --accent-to:#22d3ee;
    }
    html,body{ height:100%; margin:0; font-family:'Orbitron',sans-serif; background:var(--bg); color:#E6F7FF; -webkit-font-smoothing:antialiased; box-sizing:border-box; padding:18px; }
    nav{ margin-bottom:12px; display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    nav a{ color:inherit; text-decoration:none; padding:8px 12px; border-radius:8px; border:1px solid rgba(255,255,255,0.03); font-weight:600; display:inline-flex; gap:8px; align-items:center;}
    .container{ max-width:1100px; margin:0 auto; }
    .card{ background:var(--card-bg); padding:18px; border-radius:12px; margin-bottom:14px; }
    .card h2{ margin:0 0 6px 0; }
    .muted{ color:var(--muted); font-size:13px; }
    .grid{ display:grid; grid-template-columns: repeat(auto-fill, minmax(240px, 1fr)); gap:12px; margin-top:12px; }
    .item{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02));
      border-radius:10px; padding:10px; display:flex; flex-direction:column; gap:8px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.45);
      min-height: 220px;
    }
    .media{
      width:100%; aspect-ratio: 16 / 9; overflow:hidden; border-radius:8px; display:flex; align-items:center; justify-content:center; background:#041123;
    }
    .media img{ width:100%; height:100%; object-fit:cover; display:block; }
    .meta{ display:flex; justify-content:space-between; align-items:center; gap:8px; margin-top:6px; }
    .meta-left{ max-width:70%; }
    .name{ font-weight:800; font-size:15px; margin-bottom:6px; }
    .desc{ font-size:13px; color:var(--muted); line-height:1.2; }
    .price{ font-weight:800; font-size:16px; color:#7EE7FF; }
    .actions{ display:flex; gap:8px; margin-top:auto; align-items:center; }
    .button{ padding:8px 12px; border-radius:8px; background:linear-gradient(90deg,var(--accent-from),var(--accent-to)); color:#021125; font-weight:700; border:0; cursor:pointer; }
    .btn-ghost{ background:transparent; border:1px solid rgba(255,255,255,0.06); color:#7EE7FF; padding:8px 12px; border-radius:8px; cursor:pointer; }
    .small{ font-size:13px; }
    .toast{ position: fixed; left: 50%; transform: translateX(-50%); bottom: 18px; background: rgba(3,10,18,0.9); color:#E6F7FF; padding:8px 12px; border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,0.4); display:none; z-index:9999; }
    .lightbox{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.85); z-index:99999; padding:18px; box-sizing:border-box; }
    .lightbox.show{ display:flex; }
    .lightbox img{ max-width:100%; max-height:95vh; object-fit:contain; border-radius:8px; box-shadow:0 12px 40px rgba(0,0,0,0.6); }
    .balance{ margin-left:auto; display:flex; gap:8px; align-items:center; padding:8px 12px; border-radius:8px; border:1px solid rgba(255,255,255,0.03); }
    @media (max-width:720px){
      .grid{ grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); }
      nav{ gap:6px; }
      .balance{ width:100%; margin-left:0; justify-content:center; }
    }
    /* disabled state */
    button[disabled]{ opacity:0.6; cursor:not-allowed; }
  </style>
</head>
<body>
  <div class="container">
    <nav aria-label="Main navigation">
      <a href="index.html"><i class="fa-solid fa-gamepad"></i> Game</a>
      <a href="shop.html"><i class="fa-solid fa-mining"></i> Miners</a>
      <a href="leaderboard.html"><i class="fa-solid fa-ranking-star"></i> Leaderboard</a>
      <a href="referrals.html"><i class="fa-solid fa-user-plus"></i> Referrals</a>

      <div class="balance muted small" id="balanceBadge" title="Your current GP balance">
        <i class="fa-solid fa-coins"></i> <span id="gpAmount">—</span> GP
      </div>

      <button id="refreshBtn" class="btn-ghost" style="margin-left:8px"><i class="fa-solid fa-arrows-rotate"></i> Refresh</button>
    </nav>

    <div class="card" role="main" aria-labelledby="shopTitle">
      <h2 id="shopTitle">Miner Shop</h2>
      <p class="muted">Buy miners to increase your Hash Units. If your backend provides <code>image_url</code> (image or GIF) it will be displayed and viewable fullscreen.</p>

      <div id="itemsContainer" class="grid" aria-live="polite">
        <div class="muted">Loading items…</div>
      </div>
    </div>
  </div>

  <!-- toast -->
  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <!-- Lightbox -->
  <div id="lightbox" class="lightbox" role="dialog" aria-modal="true" tabindex="-1" onclick="hideLightbox(event)">
    <img id="lightboxImg" alt="Preview" />
  </div>

<script>
/* -------------------------
   Config + state
-------------------------*/
const API_BASE = 'https://jury-valuable-auditor-reaches.trycloudflare.com'; // set to '' to use same-origin (recommended). Replace with your backend origin if needed.
const clientState = {
  sessionId: localStorage.getItem('hexon_session') || generateUUID(),
  username: localStorage.getItem('hexon_username') || null,
  telegramId: null,
  gp: null
};
localStorage.setItem('hexon_session', clientState.sessionId);

function generateUUID(){ try { if (window.crypto && crypto.randomUUID) return crypto.randomUUID(); } catch(e){} return 'sess-'+Math.floor(Math.random()*1e12).toString(36); }
function $(id){ return document.getElementById(id); }
function showToast(msg, ms = 2500){ const t = $('toast'); if (!t) return; t.textContent = msg; t.style.display = 'block'; clearTimeout(t._hide); t._hide = setTimeout(()=> t.style.display = 'none', ms); }
function escapeHtml(s){ return String(s || '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* -------------------------
   API helper (adds headers + body fields)
-------------------------*/
async function api(path, method='GET', body=null, optsExtra={}) {
  try {
    const base = API_BASE ? API_BASE.replace(/\/$/, '') : window.location.origin;
    const url = path.startsWith('http') ? path : (base + path);
    const headers = Object.assign({}, optsExtra.headers || {});
    if (!optsExtra.skipJsonHeader && method.toUpperCase() !== 'GET') headers['Content-Type'] = headers['Content-Type'] || 'application/json';
    if (clientState.sessionId) headers['X-Session-Id'] = clientState.sessionId;
    const userHandle = clientState.username ? clientState.username : (clientState.telegramId ? ('tg_' + clientState.telegramId) : null);
    if (userHandle) headers['X-User-Handle'] = userHandle;

    const fetchOpts = { method, headers, ...optsExtra };
    if (body !== null && body !== undefined){
      if (fetchOpts.headers['Content-Type'] && fetchOpts.headers['Content-Type'].includes('application/json') && typeof body === 'object'){
        // ensure session/user fields are present
        body = Object.assign({}, body, {
          sessionId: body.sessionId || clientState.sessionId,
          username: body.username || clientState.username || null,
          telegramId: body.telegramId || clientState.telegramId || null
        });
        fetchOpts.body = JSON.stringify(body);
      } else {
        fetchOpts.body = body;
      }
    }

    const res = await fetch(url, fetchOpts);
    const txt = await res.text();
    let parsed = null;
    try { parsed = txt ? JSON.parse(txt) : null; } catch(e) { parsed = txt; }
    // attach status for debug
    if (parsed && typeof parsed === 'object') parsed._httpStatus = res.status;
    else parsed = { raw: parsed, _httpStatus: res.status };
    return parsed;
  } catch(err) {
    console.warn('api error', err);
    return null;
  }
}

/* -------------------------
   Telegram init (optional)
-------------------------*/
function initTelegram(){
  try {
    if (window.Telegram && window.Telegram.WebApp){
      const tg = window.Telegram.WebApp;
      try { if (typeof tg.ready === 'function') tg.ready(); } catch(e){}
      const u = (tg.initDataUnsafe && tg.initDataUnsafe.user) || (tg.initData && tg.initData.user) || null;
      if (u){
        clientState.telegramId = u.id;
        clientState.username = clientState.username || (u.username || `${u.first_name || ''} ${u.last_name || ''}`.trim() || null);
        if (clientState.username) localStorage.setItem('hexon_username', clientState.username);
      }
    }
  } catch(e){ console.warn('initTelegram error', e); }
}

/* -------------------------
   Discover display endpoint candidates (keeps backward compat)
-------------------------*/
const DISPLAY_ENDPOINT_CANDIDATES = [
  '/shop/items',
  '/miners/display',
  '/miners',
  '/shop/miners',
  '/api/shop/items',
  '/api/miners'
];

async function discoverDisplayEndpoint() {
  for (const p of DISPLAY_ENDPOINT_CANDIDATES) {
    try {
      const resp = await api(p, 'GET');
      if (!resp) continue;
      // accept: array, {items:[]}, {data:[]}, {items: [] inside object}
      if (Array.isArray(resp)) return p;
      if (resp && typeof resp === 'object') {
        if (Array.isArray(resp.items) || Array.isArray(resp.data)) return p;
        // sometimes endpoint returns { ok:true, items: [...] }
        for (const k of Object.keys(resp)) {
          if (Array.isArray(resp[k])) return p;
        }
      }
    } catch(e){ /* continue */ }
  }
  return null;
}

/* -------------------------
   Client init (sync session/gp)
-------------------------*/
async function loadClientState() {
  const resp = await api('/client/init', 'POST', { sessionId: clientState.sessionId });
  if (resp && resp.ok) {
    clientState.sessionId = resp.sessionId || clientState.sessionId;
    clientState.username = resp.username || clientState.username;
    clientState.gp = (typeof resp.gp !== 'undefined') ? Number(resp.gp) : clientState.gp;
    localStorage.setItem('hexon_session', clientState.sessionId);
    if (clientState.username) localStorage.setItem('hexon_username', clientState.username);
  } else {
    // don't treat absence as fatal; just log
    console.debug('client/init failed or returned non-ok', resp);
  }
  updateBalanceUI();
}

function updateBalanceUI(){
  const gpEl = $('gpAmount');
  gpEl.textContent = (clientState.gp === null || typeof clientState.gp === 'undefined') ? '—' : Number(clientState.gp).toLocaleString();
}

/* -------------------------
   Render shop & buy flow (aligned to server)
-------------------------*/
let discoveredEndpoint = null;

async function loadShop(){
  initTelegram();
  const container = $('itemsContainer');
  container.innerHTML = '<div class="muted">Loading items…</div>';

  // sync client state
  await loadClientState();

  // find display endpoint
  if (!discoveredEndpoint) {
    discoveredEndpoint = await discoverDisplayEndpoint();
    if (!discoveredEndpoint) {
      container.innerHTML = '<div class="muted">Shop unavailable (no display endpoint found)</div>';
      return;
    }
  }

  // fetch items
  const itemsResp = await api(discoveredEndpoint, 'GET');
  if (!itemsResp) {
    container.innerHTML = '<div class="muted">Shop unavailable (failed to fetch items)</div>';
    return;
  }

  // normalize items (array may be top-level or nested)
  let items = [];
  if (Array.isArray(itemsResp)) items = itemsResp;
  else if (Array.isArray(itemsResp.items)) items = itemsResp.items;
  else if (Array.isArray(itemsResp.data)) items = itemsResp.data;
  else {
    for (const k of Object.keys(itemsResp)) {
      if (Array.isArray(itemsResp[k])) { items = itemsResp[k]; break; }
    }
  }

  if (!items || items.length === 0){
    container.innerHTML = '<div class="muted">No items available</div>';
    return;
  }

  container.innerHTML = '';
  for (const rawItem of items){
    // SAFELY extract canonical fields from server item
    const item = Object.assign({}, rawItem); // shallow copy
    const numericId = (typeof item.id === 'number') ? item.id : (typeof item.item_id === 'number' ? item.item_id : null);
    // If id is string but digits, coerce
    if (numericId === null && typeof item.id === 'string' && /^[0-9]+$/.test(item.id)) {
      item.id = Number(item.id);
    }
    const rawIdCandidates = [
      item.id,
      item.item_id,
      item.sku,
      item.code,
      item.miner_id,
      item._id
    ];
    let chosenToken = null;
    for (const c of rawIdCandidates) {
      if (typeof c !== 'undefined' && c !== null && String(c).trim() !== '') {
        chosenToken = c;
        break;
      }
    }
    if (chosenToken === null) {
      // skip malformed item
      console.warn('Skipping malformed shop item (no usable id):', item);
      continue;
    }
    // string form for display and sending
    const chosenIdStr = String(chosenToken);
    const name = String(item.name || item.title || 'Unnamed Miner');
    const desc = String(item.description || item.desc || '');
    const price = Number(item.price_gp ?? item.priceGP ?? item.price ?? 0);
    const imageUrl = String(item.image_url || item.image || item.imageUrl || '') || null;

    // build card
    const card = document.createElement('div');
    card.className = 'item';

    // Build inner HTML but avoid embedding unescaped user data into attributes; we'll set dataset values via JS
    card.innerHTML = `
      <div class="media" role="button" tabindex="0" aria-label="Preview ${escapeHtml(name)}">
        ${ imageUrl ? `<img loading="lazy" src="${escapeHtml(imageUrl)}" alt="${escapeHtml(name)}">` : `<div class="muted small" style="padding:12px">No image</div>` }
      </div>
      <div class="meta">
        <div class="meta-left">
          <div class="name">${escapeHtml(name)}</div>
          <div class="desc">${escapeHtml(desc)}</div>
        </div>
        <div style="text-align:right">
          <div class="price">${price.toLocaleString()} GP</div>
          <div class="small muted" style="margin-top:6px">ID: ${escapeHtml(chosenIdStr)}</div>
        </div>
      </div>
      <div class="actions">
        <button class="button buyBtn"><i class="fa-solid fa-cart-plus"></i> Buy</button>
        <button class="btn-ghost viewBtn" ${imageUrl ? '' : 'disabled'}>${ imageUrl ? '<i class="fa-solid fa-eye"></i> View' : '<i class="fa-solid fa-image"></i> No preview'}</button>
      </div>
    `;
    container.appendChild(card);

    // attach dataset metadata (safe)
    const buyBtn = card.querySelector('.buyBtn');
    const viewBtn = card.querySelector('.viewBtn');
    const mediaEl = card.querySelector('.media');

    // dataset: include multiple identifiers to maximize backend compatibility
    buyBtn.dataset.itemId = chosenIdStr;                       // itemId (string form)
    if (typeof item.id !== 'undefined' && item.id !== null) buyBtn.dataset.id = String(item.id);
    if (typeof item.item_id !== 'undefined' && item.item_id !== null) buyBtn.dataset.item_id = String(item.item_id);
    if (typeof item.sku !== 'undefined' && item.sku !== null) buyBtn.dataset.sku = String(item.sku);
    buyBtn.dataset.price = String(price);
    buyBtn.dataset.name = String(name);

    // initial enable/disable depending on GP
    function refreshBuyState(){
      if (clientState.gp === null || typeof clientState.gp === 'undefined') {
        buyBtn.disabled = false;
        buyBtn.title = '';
        buyBtn.innerHTML = '<i class="fa-solid fa-cart-plus"></i> Buy';
        return;
      }
      if (Number(clientState.gp) < Number(price)) {
        buyBtn.disabled = true;
        buyBtn.title = 'Insufficient GP';
        buyBtn.innerHTML = `<i class="fa-solid fa-ban"></i> Need ${ (Number(price) - Number(clientState.gp)).toLocaleString() } GP`;
      } else {
        buyBtn.disabled = false;
        buyBtn.title = '';
        buyBtn.innerHTML = '<i class="fa-solid fa-cart-plus"></i> Buy';
      }
    }
    refreshBuyState();

    // view/lightbox handler
    const openPreview = () => {
      if (!imageUrl) return;
      showLightbox(imageUrl);
    };
    if (viewBtn && imageUrl) viewBtn.addEventListener('click', openPreview);
    if (mediaEl && imageUrl){
      mediaEl.addEventListener('click', openPreview);
      mediaEl.addEventListener('keydown', (e)=>{ if (e.key === 'Enter' || e.key === ' ') openPreview(); });
    }

    // BUY handler (robust payload that backend accepts)
    buyBtn.addEventListener('click', async () => {
      // gather ids to send
      const idStr = buyBtn.dataset.itemId || buyBtn.dataset.id || buyBtn.dataset.sku || buyBtn.dataset.item_id || '';
      if (!idStr) {
        showToast('Invalid item id — cannot buy.');
        return;
      }
      const nameLabel = buyBtn.dataset.name || 'item';
      const priceNum = Number(buyBtn.dataset.price || 0);
      if (!confirm(`Buy "${nameLabel}" for ${priceNum.toLocaleString()} GP?`)) return;

      // disable UI while processing
      buyBtn.disabled = true;
      const origHtml = buyBtn.innerHTML;
      buyBtn.innerHTML = 'Processing…';

      // prepare a payload that increases compatibility:
      // - itemId (string), id (string), sku (if present)
      // - item_id (numeric) if this is numeric
      const payload = {
        sessionId: clientState.sessionId,
        username: clientState.username || null,
        itemId: idStr,
        id: buyBtn.dataset.id || idStr,
      };
      if (buyBtn.dataset.sku) payload.sku = buyBtn.dataset.sku;
      // add numeric item_id when possible (server expects bigint)
      if (buyBtn.dataset.item_id && /^[0-9]+$/.test(buyBtn.dataset.item_id)) {
        payload.item_id = Number(buyBtn.dataset.item_id);
      } else if (/^[0-9]+$/.test(idStr)) {
        // if chosen id string is numeric, include numeric item_id too
        payload.item_id = Number(idStr);
      }

      // Try the preferred buy path first (/shop/buy) — backend expects this
      const buyPaths = ['/shop/buy', '/buy', '/miners/buy', '/api/shop/buy'];
      let resp = null;
      for (const p of buyPaths) {
        try {
          resp = await api(p, 'POST', payload);
        } catch(e) {
          console.warn('buy attempt error', e);
          resp = null;
        }
        // if we got a clear response object with ok/error fields, stop trying
        if (resp && (typeof resp.ok !== 'undefined' || typeof resp.error !== 'undefined' || resp._httpStatus)) break;
      }

      // handle response cases
      if (!resp) {
        showToast('Network/server error while buying. Check console for details.', 3500);
        console.error('Buy failed: no response', payload);
        buyBtn.disabled = false;
        buyBtn.innerHTML = origHtml;
        return;
      }

      if (resp.ok) {
        // server returned success. Prefer authoritative gp if provided
        if (typeof resp.gp !== 'undefined') {
          clientState.gp = Number(resp.gp);
        } else if (resp.purchased && typeof resp.purchased.price !== 'undefined') {
          // fallback: subtract price locally if server didn't send gp
          clientState.gp = (clientState.gp === null ? null : clientState.gp - Number(resp.purchased.price));
        }
        updateBalanceUI();

        const purchasedId = resp.purchased && typeof resp.purchased.itemId !== 'undefined' ? resp.purchased.itemId : (payload.item_id ?? payload.id ?? payload.itemId);
        showToast(`Purchase successful — id: ${purchasedId}`, 1800);
        console.info('Purchase response:', resp);

        // refresh shop to reflect updated gp/miners
        await loadClientState();
        await loadShop();
        return;
      } else {
        // error case — surface server-provided error if available
        let errMsg = 'Purchase failed';
        if (typeof resp.error !== 'undefined') errMsg = String(resp.error);
        else if (resp && resp.raw) errMsg = String(resp.raw);
        else if (resp && resp.message) errMsg = String(resp.message);
        showToast(errMsg, 3500);
        console.warn('Buy failed response:', resp);
        buyBtn.disabled = false;
        buyBtn.innerHTML = origHtml;
        return;
      }
    }); // end buy handler
  } // end for items

  updateBalanceUI();
}

/* -------------------------
   Lightbox helpers
-------------------------*/
function showLightbox(url){
  const lb = $('lightbox');
  const img = $('lightboxImg');
  img.src = url;
  lb.classList.add('show');
  lb.focus();
}
function hideLightbox(ev){
  if (ev && ev.target && ev.target.id === 'lightboxImg') return;
  const lb = $('lightbox');
  lb.classList.remove('show');
  $('lightboxImg').src = '';
}
document.addEventListener('keydown', (e)=> { if (e.key === 'Escape') hideLightbox(); });

/* -------------------------
   Wiring & boot
-------------------------*/
$('refreshBtn').addEventListener('click', ()=> {
  loadClientState().then(() => loadShop());
});

document.addEventListener('DOMContentLoaded', ()=>{
  initTelegram();
  loadClientState().then(() => loadShop());
});
</script>
</body>
</html>
